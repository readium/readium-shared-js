{
  "version": 3,
  "sources": [
    "../../plugins/highlights/lib/class.js",
    "../../plugins/highlights/helpers.js",
    "../../plugins/highlights/models/text_line_inferrer.js",
    "../../plugins/highlights/lib/length.js",
    "../../plugins/highlights/models/copied_text_styles.js",
    "../../plugins/highlights/views/view.js",
    "../../plugins/highlights/views/border_view.js",
    "../../plugins/highlights/models/group.js",
    "../../plugins/highlights/controller.js",
    "../../plugins/highlights/manager.js",
    "../../plugins/highlights/main.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "readium-plugin-highlights.js",
  "sourcesContent": [
    "/* Simple JavaScript Inheritance\r\n * By John Resig http://ejohn.org/\r\n * MIT Licensed.\r\n */\r\n// Inspired by base2 and Prototype\r\ndefine('readium_plugin_highlights/lib/class',[],function() {\r\n\r\n    var initializing = false,\r\n        fnTest = /xyz/.test(function() {\r\n            xyz;\r\n        }) ? /\\b_super\\b/ : /.*/;\r\n\r\n    // The base Class implementation (does nothing)\r\n    var Class = function() {};\r\n\r\n    // Create a new Class that inherits from this class\r\n    Class.extend = function(prop) {\r\n        var _super = this.prototype;\r\n\r\n        // Instantiate a base class (but only create the instance,\r\n        // don't run the init constructor)\r\n        initializing = true;\r\n        var prototype = new this();\r\n        initializing = false;\r\n\r\n        // Copy the properties over onto the new prototype\r\n        for (var name in prop) {\r\n            // Check if we're overwriting an existing function\r\n            prototype[name] = typeof prop[name] == \"function\" &&\r\n                typeof _super[name] == \"function\" && fnTest.test(prop[name]) ?\r\n                (function(name, fn) {\r\n                    return function() {\r\n                        var tmp = this._super;\r\n\r\n                        // Add a new ._super() method that is the same method\r\n                        // but on the super-class\r\n                        this._super = _super[name];\r\n\r\n                        // The method only need to be bound temporarily, so we\r\n                        // remove it when we're done executing\r\n                        var ret = fn.apply(this, arguments);\r\n                        this._super = tmp;\r\n\r\n                        return ret;\r\n                    };\r\n                })(name, prop[name]) :\r\n                prop[name];\r\n        }\r\n\r\n        // The dummy class constructor\r\n        function Class() {\r\n            // All construction is actually done in the init method\r\n            if (!initializing && this.init)\r\n                this.init.apply(this, arguments);\r\n        }\r\n\r\n        // Populate our constructed prototype object\r\n        Class.prototype = prototype;\r\n\r\n        // Enforce the constructor to be what we expect\r\n        Class.prototype.constructor = Class;\r\n\r\n        // And make this class extendable\r\n        Class.extend = arguments.callee;\r\n\r\n        return Class;\r\n    };\r\n\r\n    return Class;\r\n});\r\n\n",
    "define('readium_plugin_highlights/helpers',[],function() {\r\n    var HighlightHelpers = {\r\n        getMatrix: function($obj) {\r\n            var matrix = $obj.css(\"-webkit-transform\") ||\r\n                $obj.css(\"-moz-transform\") ||\r\n                $obj.css(\"-ms-transform\") ||\r\n                $obj.css(\"-o-transform\") ||\r\n                $obj.css(\"transform\");\r\n            return matrix === \"none\" ? undefined : matrix;\r\n        },\r\n        getScaleFromMatrix: function(matrix) {\r\n            var matrixRegex = /matrix\\((-?\\d*\\.?\\d+),\\s*0,\\s*0,\\s*(-?\\d*\\.?\\d+),\\s*0,\\s*0\\)/,\r\n                matches = matrix.match(matrixRegex);\r\n            return matches[1];\r\n        }\r\n    };\r\n\r\n    return HighlightHelpers;\r\n});\r\n\n",
    "define('readium_plugin_highlights/models/text_line_inferrer',[\"../lib/class\"], function(Class) {\r\n    var TextLineInferrer = Class.extend({\r\n\r\n        init: function(options) {\r\n            this.lineHorizontalThreshold = options.lineHorizontalThreshold || 0;\r\n            this.lineHorizontalLimit = options.lineHorizontalLimit || 0;\r\n        },\r\n\r\n        // ----------------- PUBLIC INTERFACE --------------------------------------------------------------\r\n\r\n        inferLines: function(rectTextList) {\r\n            var inferredLines = [];\r\n            var numRects = rectTextList.length;\r\n            var numLines = 0;\r\n            var currLine;\r\n            var currRect;\r\n            var currRectTextObj;\r\n            var rectAppended;\r\n\r\n            // Iterate through each rect\r\n            for (var currRectNum = 0; currRectNum <= numRects - 1; currRectNum++) {\r\n                currRectTextObj = rectTextList[currRectNum];\r\n                currRect = currRectTextObj.rect;\r\n                // Check if the rect can be added to any of the current lines\r\n                rectAppended = false;\r\n\r\n                if (inferredLines.length > 0) {\r\n                    currLine = inferredLines[inferredLines.length - 1];\r\n\r\n                    if (this.includeRectInLine(currLine.line, currRect.top, currRect.left,\r\n                            currRect.width, currRect.height)) {\r\n                        rectAppended = this.expandLine(currLine.line, currRect.left, currRect.top,\r\n                            currRect.width, currRect.height);\r\n\r\n                        currLine.data.push(currRectTextObj);\r\n                    }\r\n                }\r\n\r\n                if (!rectAppended) {\r\n                    inferredLines.push({\r\n                        data: [currRectTextObj],\r\n                        line: this.createNewLine(currRect.left, currRect.top,\r\n                            currRect.width, currRect.height)\r\n                    });\r\n                    // Update the number of lines, so we're not using .length on every iteration\r\n                    numLines = numLines + 1;\r\n                }\r\n            }\r\n            return inferredLines;\r\n        },\r\n\r\n\r\n        // ----------------- PRIVATE HELPERS ---------------------------------------------------------------\r\n\r\n        includeRectInLine: function(currLine, rectTop, rectLeft, rectWidth, rectHeight) {\r\n            // is on an existing line : based on vertical position\r\n            if (this.rectIsWithinLineVertically(rectTop, rectHeight, currLine.maxTop, currLine.maxBottom)) {\r\n                if (this.rectIsWithinLineHorizontally(rectLeft, rectWidth, currLine.left,\r\n                        currLine.width, currLine.avgHeight)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        },\r\n\r\n        rectIsWithinLineVertically: function(rectTop, rectHeight, currLineMaxTop, currLineMaxBottom) {\r\n            var rectBottom = rectTop + rectHeight;\r\n            var lineHeight = currLineMaxBottom - currLineMaxTop;\r\n            var lineHeightAdjustment = (lineHeight * 0.75) / 2;\r\n            var rectHeightAdjustment = (rectHeight * 0.75) / 2;\r\n\r\n            rectTop = rectTop + rectHeightAdjustment;\r\n            rectBottom = rectBottom - rectHeightAdjustment;\r\n            currLineMaxTop = currLineMaxTop + lineHeightAdjustment;\r\n            currLineMaxBottom = currLineMaxBottom - lineHeightAdjustment;\r\n\r\n            if (rectTop === currLineMaxTop && rectBottom === currLineMaxBottom) {\r\n                return true;\r\n            } else if (rectTop < currLineMaxTop && rectBottom < currLineMaxBottom &&\r\n                rectBottom > currLineMaxTop) {\r\n                return true;\r\n            } else if (rectTop > currLineMaxTop && rectBottom > currLineMaxBottom &&\r\n                rectTop < currLineMaxBottom) {\r\n                return true;\r\n            } else if (rectTop > currLineMaxTop && rectBottom < currLineMaxBottom) {\r\n                return true;\r\n            } else if (rectTop < currLineMaxTop && rectBottom > currLineMaxBottom) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        },\r\n\r\n        rectIsWithinLineHorizontally: function(rectLeft, rectWidth, currLineLeft, currLineWidth,\r\n            currLineAvgHeight) {\r\n            var lineGapHeuristic = 2 * currLineAvgHeight;\r\n            var rectRight = rectLeft + rectWidth;\r\n            var currLineRight = rectLeft + currLineWidth;\r\n\r\n            if ((currLineLeft - rectRight) > lineGapHeuristic) {\r\n                return false;\r\n            } else if ((rectLeft - currLineRight) > lineGapHeuristic) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        },\r\n\r\n        createNewLine: function(rectLeft, rectTop, rectWidth, rectHeight) {\r\n            var maxBottom = rectTop + rectHeight;\r\n\r\n            return {\r\n                left: rectLeft,\r\n                startTop: rectTop,\r\n                width: rectWidth,\r\n                avgHeight: rectHeight,\r\n                maxTop: rectTop,\r\n                maxBottom: maxBottom,\r\n                numRects: 1\r\n            };\r\n        },\r\n\r\n        expandLine: function(currLine, rectLeft, rectTop, rectWidth, rectHeight) {\r\n            var lineOldRight = currLine.left + currLine.width;\r\n\r\n            // Update all the properties of the current line with rect dimensions\r\n            var rectRight = rectLeft + rectWidth;\r\n            var rectBottom = rectTop + rectHeight;\r\n            var numRectsPlusOne = currLine.numRects + 1;\r\n\r\n            // Average height calculation\r\n            var currSumHeights = currLine.avgHeight * currLine.numRects;\r\n            var avgHeight = Math.ceil((currSumHeights + rectHeight) / numRectsPlusOne);\r\n            currLine.avgHeight = avgHeight;\r\n            currLine.numRects = numRectsPlusOne;\r\n\r\n            // Expand the line vertically\r\n            currLine = this.expandLineVertically(currLine, rectTop, rectBottom);\r\n            currLine = this.expandLineHorizontally(currLine, rectLeft, rectRight);\r\n\r\n            return currLine;\r\n        },\r\n\r\n        expandLineVertically: function(currLine, rectTop, rectBottom) {\r\n            if (rectTop < currLine.maxTop) {\r\n                currLine.maxTop = rectTop;\r\n            }\r\n            if (rectBottom > currLine.maxBottom) {\r\n                currLine.maxBottom = rectBottom;\r\n            }\r\n\r\n            return currLine;\r\n        },\r\n\r\n        expandLineHorizontally: function(currLine, rectLeft, rectRight) {\r\n            var newLineLeft = currLine.left <= rectLeft ? currLine.left : rectLeft;\r\n            var lineRight = currLine.left + currLine.width;\r\n            var newLineRight = lineRight >= rectRight ? lineRight : rectRight;\r\n            var newLineWidth = newLineRight - newLineLeft;\r\n\r\n            //cancel the expansion if the line is going to expand outside a horizontal limit\r\n            //this is used to prevent lines from spanning multiple columns in a two column epub view\r\n            var horizontalThreshold = this.lineHorizontalThreshold;\r\n            var horizontalLimit = this.lineHorizontalLimit;\r\n\r\n            var leftBoundary = Math.floor(newLineLeft / horizontalLimit) * horizontalLimit;\r\n            var centerBoundary = leftBoundary + horizontalThreshold;\r\n            var rightBoundary = leftBoundary + horizontalLimit;\r\n            if ((newLineLeft > leftBoundary && newLineRight > centerBoundary && newLineLeft < centerBoundary) || (newLineLeft > centerBoundary && newLineRight > rightBoundary)) {\r\n                return undefined;\r\n            }\r\n\r\n            currLine.left = newLineLeft;\r\n            currLine.width = newLineWidth;\r\n\r\n            return currLine;\r\n        }\r\n    });\r\n\r\n    return TextLineInferrer;\r\n});\r\n\n",
    "// https://github.com/heygrady/Units\r\n//\r\n// Copyright (c) 2013 Grady Kuhnline\r\n//\r\n// MIT License\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining\r\n// a copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to\r\n// permit persons to whom the Software is furnished to do so, subject to\r\n// the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be\r\n// included in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\ndefine('readium_plugin_highlights/lib/length',[],function() {\r\n    return function(document) {\r\n        \"use strict\";\r\n\r\n        // create a test element\r\n        var testElem = document.createElement('test'),\r\n            docElement = document.documentElement,\r\n            defaultView = document.defaultView,\r\n            getComputedStyle = defaultView && defaultView.getComputedStyle,\r\n            computedValueBug,\r\n            runit = /^(-?[\\d+\\.\\-]+)([a-z]+|%)$/i,\r\n            convert = {},\r\n            conversions = [1 / 25.4, 1 / 2.54, 1 / 72, 1 / 6],\r\n            units = ['mm', 'cm', 'pt', 'pc', 'in', 'mozmm'],\r\n            i = 6; // units.length\r\n\r\n        // add the test element to the dom\r\n        docElement.appendChild(testElem);\r\n\r\n        // test for the WebKit getComputedStyle bug\r\n        // @see http://bugs.jquery.com/ticket/10639\r\n        if (getComputedStyle) {\r\n            // add a percentage margin and measure it\r\n            testElem.style.marginTop = '1%';\r\n            computedValueBug = getComputedStyle(testElem).marginTop === '1%';\r\n        }\r\n\r\n        // pre-calculate absolute unit conversions\r\n        while (i--) {\r\n            convert[units[i] + \"toPx\"] = conversions[i] ? conversions[i] * convert.inToPx : toPx(testElem, '1' + units[i]);\r\n        }\r\n\r\n        // remove the test element from the DOM and delete it\r\n        docElement.removeChild(testElem);\r\n        testElem = undefined;\r\n\r\n        // convert a value to pixels\r\n        function toPx(elem, value, prop, force) {\r\n            // use width as the default property, or specify your own\r\n            prop = prop || 'width';\r\n\r\n            var style,\r\n                inlineValue,\r\n                ret,\r\n                unit = (value.match(runit) || [])[2],\r\n                conversion = unit === 'px' ? 1 : convert[unit + 'toPx'],\r\n                rem = /r?em/i;\r\n\r\n            if (conversion || rem.test(unit) && !force) {\r\n                // calculate known conversions immediately\r\n                // find the correct element for absolute units or rem or fontSize + em or em\r\n                elem = conversion ? elem : unit === 'rem' ? docElement : prop === 'fontSize' ? elem.parentNode || elem : elem;\r\n\r\n                // use the pre-calculated conversion or fontSize of the element for rem and em\r\n                conversion = conversion || parseFloat(curCSS(elem, 'fontSize'));\r\n\r\n                // multiply the value by the conversion\r\n                ret = parseFloat(value) // conversion;\r\n            } else {\r\n                // begin \"the awesome hack by Dean Edwards\"\r\n                // @see http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\r\n\r\n                // remember the current style\r\n                style = elem.style;\r\n                inlineValue = style[prop];\r\n\r\n                // set the style on the target element\r\n                try {\r\n                    style[prop] = value;\r\n                } catch (e) {\r\n                    // IE 8 and below throw an exception when setting unsupported units\r\n                    return 0;\r\n                }\r\n\r\n                // read the computed value\r\n                // if style is nothing we probably set an unsupported unit\r\n                ret = !style[prop] ? 0 : parseFloat(curCSS(elem, prop));\r\n\r\n                // reset the style back to what it was or blank it out\r\n                style[prop] = inlineValue !== undefined ? inlineValue : null;\r\n            }\r\n\r\n            // return a number\r\n            return ret;\r\n        }\r\n\r\n        // return the computed value of a CSS property\r\n        function curCSS(elem, prop) {\r\n            var value,\r\n                pixel,\r\n                unit,\r\n                rvpos = /^top|bottom/,\r\n                outerProp = [\"paddingTop\", \"paddingBottom\", \"borderTop\", \"borderBottom\"],\r\n                innerHeight,\r\n                parent,\r\n                i = 4; // outerProp.length\r\n\r\n            if (getComputedStyle) {\r\n                // FireFox, Chrome/Safari, Opera and IE9+\r\n                value = getComputedStyle(elem)[prop];\r\n            } else if (pixel = elem.style['pixel' + prop.charAt(0).toUpperCase() + prop.slice(1)]) {\r\n                // IE and Opera support pixel shortcuts for top, bottom, left, right, height, width\r\n                // WebKit supports pixel shortcuts only when an absolute unit is used\r\n                value = pixel + 'px';\r\n            } else if (prop === 'fontSize') {\r\n                // correct IE issues with font-size\r\n                // @see http://bugs.jquery.com/ticket/760\r\n                value = toPx(elem, '1em', 'left', 1) + 'px';\r\n            } else {\r\n                // IE 8 and below return the specified style\r\n                value = elem.currentStyle[prop];\r\n            }\r\n\r\n            // check the unit\r\n            unit = (value.match(runit) || [])[2];\r\n            if (unit === '%' && computedValueBug) {\r\n                // WebKit won't convert percentages for top, bottom, left, right, margin and text-indent\r\n                if (rvpos.test(prop)) {\r\n                    // Top and bottom require measuring the innerHeight of the parent.\r\n                    innerHeight = (parent = elem.parentNode || elem).offsetHeight;\r\n                    while (i--) {\r\n                        innerHeight -= parseFloat(curCSS(parent, outerProp[i]));\r\n                    }\r\n                    value = parseFloat(value) / 100 // innerHeight + 'px';\r\n                } else {\r\n                    // This fixes margin, left, right and text-indent\r\n                    // @see https://bugs.webkit.org/show_bug.cgi?id=29084\r\n                    // @see http://bugs.jquery.com/ticket/10639\r\n                    value = toPx(elem, value);\r\n                }\r\n            } else if ((value === 'auto' || (unit && unit !== 'px')) && getComputedStyle) {\r\n                // WebKit and Opera will return auto in some cases\r\n                // Firefox will pass back an unaltered value when it can't be set, like top on a static element\r\n                value = 0;\r\n            } else if (unit && unit !== 'px' && !getComputedStyle) {\r\n                // IE 8 and below won't convert units for us\r\n                // try to convert using a prop that will return pixels\r\n                // this will be accurate for everything (except font-size and some percentages)\r\n                value = toPx(elem, value) + 'px';\r\n            }\r\n            return value;\r\n        }\r\n\r\n        // export the conversion function\r\n        return {\r\n            toPx: toPx\r\n        };\r\n    };\r\n});\r\n\n",
    "define('readium_plugin_highlights/models/copied_text_styles',[],function() {\r\n    return [\r\n        \"color\",\r\n        \"font-family\",\r\n        \"font-size\",\r\n        \"font-weight\",\r\n        \"font-style\",\r\n        //\"line-height\",\r\n        \"text-decoration\",\r\n        \"text-transform\",\r\n        \"text-shadow\",\r\n        \"letter-spacing\",\r\n\r\n        \"text-rendering\",\r\n        \"font-kerning\",\r\n        \"font-language-override\",\r\n        \"font-size-adjust\",\r\n        \"font-stretch\",\r\n        \"font-synthesis\",\r\n        \"font-variant\",\r\n        \"font-variant-alternates\",\r\n        \"font-variant-caps\",\r\n        \"font-variant-east-asian\",\r\n        \"font-variant-ligatures\",\r\n        \"font-variant-numeric\",\r\n        \"font-variant-position\",\r\n        \"-webkit-font-smoothing \",\r\n\r\n        \"-ms-writing-mode\",\r\n        \"-webkit-writing-mode\",\r\n        \"-moz-writing-mode\",\r\n        \"-ms-writing-mode\",\r\n        \"writing-mode\",\r\n\r\n        \"-webkit-text-orientation\",\r\n        \"-moz-text-orientation\",\r\n        \"-ms-text-orientation\",\r\n        \"text-orientation: mixed\"\r\n    ];\r\n});\r\n\n",
    "define('readium_plugin_highlights/views/view',[\"jquery\", \"underscore\", \"../lib/class\", \"../lib/length\", \"../models/text_line_inferrer\", \"../models/copied_text_styles\"],\r\nfunction($, _, Class, Length, TextLineInferrer, CopiedTextStyles) {\r\n    // This is not a backbone view.\r\n\r\n    var HighlightView = Class.extend({\r\n        // this is an element that highlight will be associated with, it is not styled at this point\r\n        template: \"<div class=\\\"rd-highlight\\\"></div>\",\r\n\r\n        init: function(context, options) {\r\n            this.context = context;\r\n\r\n            this.lengthLib = new Length(this.context.document);\r\n\r\n            this.highlight = {\r\n                id: options.id,\r\n                CFI: options.CFI,\r\n                type: options.type,\r\n                top: options.top,\r\n                left: options.left,\r\n                height: options.height,\r\n                width: options.width,\r\n                styles: options.styles,\r\n                contentRenderData: options.contentRenderData\r\n            };\r\n\r\n            this.swipeThreshold = 10;\r\n            this.swipeVelocity = 0.65; // in px/ms\r\n        },\r\n\r\n        render: function() {\r\n            this.$el = $(this.template, this.context.document);\r\n            this.$el.attr('data-id', this.highlight.id);\r\n            this.updateStyles();\r\n            this.renderContent();\r\n            return this.$el;\r\n        },\r\n\r\n        remove: function() {\r\n            this.highlight = null;\r\n            this.context = null;\r\n            this.$el.remove();\r\n        },\r\n\r\n\r\n\r\n        resetPosition: function(top, left, height, width) {\r\n            _.assign(this.highlight, {\r\n                top: top,\r\n                left: left,\r\n                height: height,\r\n                width: width\r\n            });\r\n            this.setCSS();\r\n        },\r\n\r\n        setStyles: function(styles) {\r\n            this.highlight.styles = styles;\r\n            this.updateStyles();\r\n        },\r\n\r\n        update: function(type, styles) {\r\n            // save old type\r\n            var oldType = this.highlight.type;\r\n\r\n            _.assign(this.highlight, {\r\n                type: type,\r\n                styles: styles\r\n            });\r\n\r\n            // we need to fully restyle view elements\r\n            // remove all the \"inline\" styles\r\n            this.$el.removeAttr(\"style\");\r\n\r\n            // remove class applied by \"type\"\r\n            this.$el.removeClass(oldType);\r\n\r\n            this.updateStyles();\r\n        },\r\n\r\n        updateStyles: function() {\r\n            this.setBaseHighlight();\r\n            this.setCSS();\r\n        },\r\n\r\n        // Will return null or false if :first-line/letter would not apply to the first text node child\r\n        getFirstTextNodeChild: function(elem) {\r\n            for (var i = 0; i < elem.childNodes.length; i++) {\r\n                var child = elem.childNodes[i];\r\n                if (child.nodeType === Node.TEXT_NODE) {\r\n                    return child;\r\n                }\r\n\r\n                if (child.nodeType === Node.ELEMENT_NODE) {\r\n                    var doc = child.ownerDocument;\r\n                    var style = doc.defaultView.getComputedStyle(child);\r\n                    // If it's not an element we can definitely ignore\r\n                    if ((style['position'] !== 'absolute' && style['position'] !== 'fixed') &&\r\n                        style['float'] === 'none' && style['display'] !== 'none') {\r\n                        if (style['display'] === 'inline') {\r\n                            var result = this.getFirstTextNodeChild(child);\r\n                            if (result) {\r\n                                return result;\r\n                            } else if (result === false) {\r\n                                return false;\r\n                            }\r\n                        } else {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        },\r\n\r\n        // Returns the styles which apply to the first line of the specified element, or null if there aren't any\r\n        // Assumes that the specified argument is a block element\r\n        getFirstLineStyles: function(elem) {\r\n            var win = elem.ownerDocument.defaultView;\r\n            if (!win.getMatchedCSSRules) {\r\n                // Without getMatchingCSSRules, we can't get first-line styles\r\n                return null;\r\n            }\r\n            while (elem) {\r\n                var styles = win.getMatchedCSSRules(elem, 'first-line');\r\n                if (styles) {\r\n                    return styles[0].style;\r\n                }\r\n\r\n                // Go through previous siblings, return null if there's a non-empty text node, or an element that's\r\n                // not display: none; - both of these prevent :first-line styles from the parents from applying\r\n                var sibling = elem;\r\n                while (sibling = sibling.previousSibling) {\r\n                    if (sibling.nodeType === Node.ELEMENT_NODE) {\r\n                        var siblingStyles = win.getComputedStyle(sibling);\r\n                        if (siblingStyles['display'] !== 'none') {\r\n                            return null;\r\n                        }\r\n                    } else if (sibling.nodeType === Node.TEXT_NODE && sibling.textContent.match(/\\S/)) {\r\n                        return null;\r\n                    }\r\n                };\r\n                elem = elem.parentNode;\r\n            }\r\n        },\r\n\r\n        renderContent: function() {\r\n            var that = this;\r\n            var renderData = this.highlight.contentRenderData;\r\n            if (renderData) {\r\n                _.each(renderData.data, function(data) {\r\n                    var $ancestor = $(data.ancestorEl);\r\n                    var $blockAncestor = $(data.blockAncestorEl);\r\n                    var document = data.ancestorEl.ownerDocument;\r\n\r\n                    var el = document.createElement(\"div\");\r\n                    el.style.position = 'absolute';\r\n                    el.style.top = (data.rect.top - renderData.top) + \"px\";\r\n                    el.style.left = (data.rect.left - renderData.left) + \"px\";\r\n                    el.style.width = (data.rect.width + 1) + \"px\";\r\n                    el.style.height = data.rect.height + \"px\";\r\n\r\n                    var copyStyles = function(copyFrom, copyTo) {\r\n                        _.each(CopiedTextStyles, function(styleName) {\r\n                            var style = copyFrom[styleName];\r\n                            if (style) {\r\n                                copyTo[styleName] = style;\r\n                            }\r\n                        });\r\n                    };\r\n\r\n                    var copiedStyles = $ancestor.data(\"rd-copied-text-styles\");\r\n                    if (!copiedStyles) {\r\n                        copiedStyles = {};\r\n                        var computedStyle = document.defaultView.getComputedStyle(data.ancestorEl);\r\n                        copyStyles(computedStyle, copiedStyles);\r\n                        $ancestor.data(\"rd-copied-text-styles\", copiedStyles);\r\n                    }\r\n\r\n                    var copiedFirstLineStyles = $blockAncestor.data(\"rd-copied-first-line-styles\");\r\n                    if (copiedFirstLineStyles === undefined) {\r\n                        copiedFirstLineStyles = null;\r\n                        var firstLineStyles = that.getFirstLineStyles(data.blockAncestorEl);\r\n                        if (firstLineStyles) {\r\n                            copiedFirstLineStyles = {};\r\n                            copyStyles(firstLineStyles, copiedFirstLineStyles);\r\n                            // Delete text-transform because it doesn't apply in Chrome on :first-line\r\n                            delete copiedFirstLineStyles['text-transform'];\r\n                            _.each([\"font-size\", \"letter-spacing\"], function(styleName) {\r\n                                if (copiedFirstLineStyles[styleName]) {\r\n                                    copiedFirstLineStyles[styleName] = that.lengthLib.toPx(data.ancestorEl, copiedFirstLineStyles[styleName]) + \"px\";\r\n                                }\r\n                            });\r\n                        }\r\n                        $blockAncestor.data(\"rd-copied-first-line-styles\", copiedFirstLineStyles);\r\n                    }\r\n\r\n                    if (copiedFirstLineStyles) {\r\n                        var textNode = that.getFirstTextNodeChild(data.blockAncestorEl);\r\n                        var range = document.createRange();\r\n                        range.setStart(textNode, 0);\r\n                        range.setEnd(data.node, data.startOffset + 1);\r\n                        var rects = range.getClientRects();\r\n                        var inferrer = new TextLineInferrer({\r\n                            lineHorizontalThreshold: $(\"body\", document).clientWidth,\r\n                            lineHorizontalLimit: document.defaultView.innerWidth\r\n                        });\r\n                        if (inferrer.inferLines(_.map(rects, function(rect) {\r\n                                return {\r\n                                    rect: rect\r\n                                }\r\n                            })).length > 1) {\r\n                            copiedFirstLineStyles = null;\r\n                        }\r\n                    }\r\n\r\n                    _.each(copiedStyles, function(style, styleName) {\r\n                        style = copiedFirstLineStyles ? copiedFirstLineStyles[styleName] || style : style;\r\n                        el.style[styleName] = style;\r\n                    });\r\n                    el.style[\"line-height\"] = data.rect.height + \"px\";\r\n\r\n                    el.appendChild(document.createTextNode(data.text));\r\n                    that.$el[0].appendChild(el);\r\n                });\r\n                processedElements = null;\r\n                computedStyles = null;\r\n            }\r\n        },\r\n\r\n        setCSS: function() {\r\n            // set highlight's absolute position\r\n            this.$el.css({\r\n                \"position\": \"absolute\",\r\n                \"top\": this.highlight.top + \"px\",\r\n                \"left\": this.highlight.left + \"px\",\r\n                \"height\": this.highlight.height + \"px\",\r\n                \"width\": this.highlight.width + \"px\"\r\n            });\r\n\r\n            // apply styles, if any\r\n            var styles = this.highlight.styles || {};\r\n            try {\r\n                this.$el.css(styles);\r\n            } catch (ex) {\r\n                console.log('EpubAnnotations: invalid css styles');\r\n            }\r\n        },\r\n\r\n        setBaseHighlight: function(removeFocus) {\r\n            var type = this.highlight.type;\r\n            this.$el.addClass(type);\r\n            this.$el.removeClass(\"hover-\" + type);\r\n            if (removeFocus) {\r\n                this.$el.removeClass(\"focused-\" + type);\r\n            }\r\n        },\r\n\r\n        setHoverHighlight: function() {\r\n            var type = this.highlight.type;\r\n            this.$el.addClass(\"hover-\" + type);\r\n            this.$el.removeClass(type);\r\n        },\r\n\r\n        setFocusedHighlight: function() {\r\n            var type = this.highlight.type;\r\n            this.$el.addClass(\"focused-\" + type);\r\n            this.$el.removeClass(type).removeClass(\"hover-\" + type);\r\n        },\r\n\r\n        setVisibility: function(value) {\r\n            if (value) {\r\n                this.$el.css('display', '');\r\n            } else {\r\n                this.$el.css('display', 'none');\r\n            }\r\n        },\r\n\r\n    });\r\n\r\n    return HighlightView;\r\n});\r\n\n",
    "define('readium_plugin_highlights/views/border_view',[\"./view\"], function(HighlightView) {\r\n\r\n    // This is not a backbone view.\r\n\r\n    var HighlightBorderView = HighlightView.extend({\r\n\r\n        template: \"<div class=\\\"rd-highlight-border\\\"></div>\",\r\n\r\n        setCSS: function() {\r\n\r\n            this.$el.css({\r\n                backgroundClip: 'padding-box',\r\n                borderStyle: 'solid',\r\n                borderWidth: '5px',\r\n                boxSizing: \"border-box\"\r\n            });\r\n            this._super();\r\n        },\r\n\r\n        setBaseHighlight: function() {\r\n\r\n            this.$el.addClass(\"highlight-border\");\r\n            this.$el.removeClass(\"hover-highlight-border\").removeClass(\"focused-highlight-border\");\r\n        },\r\n\r\n        setHoverHighlight: function() {\r\n\r\n            this.$el.addClass(\"hover-highlight-border\");\r\n            this.$el.removeClass(\"highlight-border\");\r\n        },\r\n\r\n        setFocusedHighlight: function() {\r\n            this.$el.addClass('focused-highlight-border');\r\n            this.$el.removeClass('highlight-border').removeClass('hover-highlight-border');\r\n        }\r\n    });\r\n\r\n    return HighlightBorderView;\r\n});\r\n\n",
    "define('readium_plugin_highlights/models/group',[\"jquery\", \"underscore\", \"../lib/class\", \"./text_line_inferrer\", \"../views/view\", \"../views/border_view\", \"../helpers\"],\r\nfunction($, _, Class, TextLineInferrer, HighlightView, HighlightBorderView, HighlightHelpers) {\r\n\r\n    var debouncedTrigger = _.debounce(\r\n        function(fn, eventName) {\r\n            fn(eventName);\r\n        }, 10);\r\n\r\n    var HighlightGroup = Class.extend({\r\n\r\n        init: function(context, options) {\r\n            this.context = context;\r\n\r\n            this.highlightViews = [];\r\n\r\n            this.CFI = options.CFI;\r\n            this.selectedNodes = options.selectedNodes;\r\n            this.offsetTopAddition = options.offsetTopAddition;\r\n            this.offsetLeftAddition = options.offsetLeftAddition;\r\n            this.styles = options.styles;\r\n            this.id = options.id;\r\n            this.type = options.type;\r\n            this.scale = options.scale;\r\n            this.selectionText = options.selectionText;\r\n            this.visible = options.visible;\r\n            this.rangeInfo = options.rangeInfo;\r\n\r\n            this.constructHighlightViews();\r\n        },\r\n\r\n        onHighlightEvent: function(event, type) {\r\n            var that = this;\r\n            var documentFrame = this.context.iframe;\r\n            var topView = this.context.manager;\r\n            var triggerEvent = _.partial(topView.trigger, _, that.type,\r\n                that.CFI, that.id, event, documentFrame);\r\n\r\n            if (type === \"click\" || type === \"touchend\") {\r\n                debouncedTrigger(triggerEvent, \"annotationClicked\");\r\n\r\n            } else if (type === \"contextmenu\") {\r\n                triggerEvent(\"annotationRightClicked\");\r\n\r\n            } else if (type === \"mousemove\") {\r\n                triggerEvent(\"annotationMouseMove\");\r\n\r\n            } else if (type === \"mouseenter\") {\r\n                triggerEvent(\"annotationHoverIn\");\r\n\r\n            } else if (type === \"mouseleave\") {\r\n                triggerEvent(\"annotationHoverOut\");\r\n\r\n            } else if (type === \"mousedown\") {\r\n                // prevent selection when right clicking\r\n                var preventEvent = function(event) {\r\n                    event.preventDefault();\r\n                    event.stopPropagation();\r\n                    documentFrame.contentDocument.removeEventListener(event.type, preventEvent);\r\n                };\r\n                if (event.button === 2) {\r\n                    event.preventDefault();\r\n                    documentFrame.contentDocument.addEventListener(\"selectstart\", preventEvent);\r\n                    documentFrame.contentDocument.addEventListener(\"mouseup\", preventEvent);\r\n                    documentFrame.contentDocument.addEventListener(\"click\", preventEvent);\r\n                    documentFrame.contentDocument.addEventListener(\"contextmenu\", preventEvent);\r\n                }\r\n            }\r\n\r\n            // \"mouseenter\" and \"mouseleave\" events not only trigger corresponding named event, but also\r\n            // affect the appearance\r\n            if (type === \"mouseenter\" || type === \"mouseleave\") {\r\n                // Change appearance of highlightViews constituting this highlight group\r\n                // do not iterate over secondary highlight views (hightlightViewsSecondary)\r\n                _.each(this.highlightViews, function(highlightView) {\r\n\r\n                    if (type === \"mouseenter\") {\r\n                        highlightView.setHoverHighlight();\r\n                    } else if (type === \"mouseleave\") {\r\n                        highlightView.setBaseHighlight(false);\r\n                    }\r\n                });\r\n            }\r\n\r\n        },\r\n\r\n        normalizeRectangle: function(rect) {\r\n            return {\r\n                left: rect.left,\r\n                right: rect.right,\r\n                top: rect.top,\r\n                bottom: rect.bottom,\r\n                width: rect.right - rect.left,\r\n                height: rect.bottom - rect.top\r\n            };\r\n        },\r\n\r\n        // produces an event string corresponding to \"pointer events\" that we want to monitor on the\r\n        // bound HL container. We are adding namespace to the event names in order to be able to\r\n        // remove them by specifying <eventname>.<namespace> only, rather than classic callback function\r\n        getBoundHighlightContainerEvents: function() {\r\n            // these are the event names that we handle in \"onHighlightEvent\"\r\n            var boundHighlightContainerEvents = [\"click\", \"touchstart\", \"touchend\", \"touchmove\", \"contextmenu\",\r\n                \"mouseenter\", \"mouseleave\", \"mousemove\", \"mousedown\"\r\n            ];\r\n            var namespace = \".rdjsam-\" + this.id;\r\n            return boundHighlightContainerEvents.map(function(e) {\r\n                return e + namespace;\r\n            }).join(\" \");\r\n        },\r\n\r\n        getFirstBlockParent: function(elem) {\r\n            var win = elem.ownerDocument.defaultView;\r\n            do {\r\n                var style = win.getComputedStyle(elem);\r\n                if (style['display'] !== 'inline') {\r\n                    return elem;\r\n                }\r\n            } while (elem = elem.parentNode);\r\n        },\r\n\r\n        // construct view for each rectangle constituting HL group\r\n        constructHighlightViews: function() {\r\n            var that = this;\r\n            if (!this.visible)\r\n                return;\r\n\r\n            var rectTextList = [];\r\n\r\n            // this is an array of elements (not Node.TEXT_NODE) that are part of HL group\r\n            // they will presented as HighlightBorderView\r\n            var rectElementList = [];\r\n            var inferrer;\r\n            var inferredLines;\r\n            var allContainerRects = [];\r\n            var hoverThreshold = 2; // Pixels to expand each rect on each side, for hovering/clicking purposes\r\n            var rangeInfo = this.rangeInfo;\r\n            var selectedNodes = this.selectedNodes;\r\n            var includeMedia = this.includeMedia;\r\n            var contentDocumentFrame = this.context.iframe;\r\n            var highlightStyles = this.styles;\r\n            var cloneTextMode = highlightStyles ? highlightStyles['-rd-highlight-mode'] === 'clone-text' : false;\r\n\r\n            function pushToRectTextList(range) {\r\n                var match,\r\n                    rangeText = range.toString(),\r\n                    rects = [],\r\n                    node = range.startContainer,\r\n                    ancestor = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE ? range.commonAncestorContainer : range.commonAncestorContainer.parentNode,\r\n                    blockAncestor = that.getFirstBlockParent(ancestor),\r\n                    baseOffset = range.startOffset,\r\n                    rgx = /\\S+/g;\r\n\r\n                if (cloneTextMode) {\r\n                    while (match = rgx.exec(rangeText)) {\r\n                        var startOffset = baseOffset + rgx.lastIndex - match[0].length,\r\n                            endOffset = baseOffset + rgx.lastIndex;\r\n                        range.setStart(node, startOffset);\r\n                        range.setEnd(node, endOffset);\r\n                        var clientRects = range.getClientRects();\r\n                        var curRect = 0;\r\n                        var curStart = startOffset;\r\n                        var curEnd = curStart;\r\n                        while (curRect < clientRects.length) {\r\n                            var saveRect = false;\r\n                            if (clientRects[curRect].width === 0 || clientRects[curRect].height === 0) {\r\n                                curRect++;\r\n                                continue;\r\n                            }\r\n                            if (curRect === clientRects.length - 1) {\r\n                                curEnd = endOffset;\r\n                                saveRect = true;\r\n                            } else {\r\n                                curEnd++;\r\n                                range.setStart(node, curStart);\r\n                                range.setEnd(node, curEnd);\r\n                                var tempRects = range.getClientRects();\r\n                                var tempRect = tempRects[0];\r\n                                // Skip over empty first rect if there is one\r\n                                if (tempRects.length > 1 && (tempRect.width === 0 || tempRect.height === 0)) {\r\n                                    tempRect = tempRects[1];\r\n                                }\r\n                                var differences = 0;\r\n                                _.each([\"top\", \"left\", \"bottom\", \"right\"], function(prop) {\r\n                                    differences += (tempRects[0][prop] !== clientRects[curRect][prop] ? 1 : 0);\r\n                                });\r\n                                if (differences === 0) {\r\n                                    saveRect = true;\r\n                                }\r\n                            }\r\n                            if (saveRect) {\r\n                                rects.push({\r\n                                    rect: clientRects[curRect],\r\n                                    text: node.textContent.substring(curStart, curEnd),\r\n                                    node: node,\r\n                                    startOffset: curStart\r\n                                });\r\n                                curRect++;\r\n                                curStart = curEnd;\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    _.each(range.getClientRects(), function(rect) {\r\n                        rects.push({\r\n                            rect: rect,\r\n                            text: rangeText\r\n                        });\r\n                    });\r\n                }\r\n                _.each(rects, function(rect) {\r\n                    var normalizedRect = that.normalizeRectangle(rect.rect);\r\n\r\n                    //filter out empty rectangles\r\n                    if (normalizedRect.width === 0 || normalizedRect.height === 0) {\r\n                        return;\r\n                    }\r\n\r\n                    // push both rect and ancestor in the list\r\n                    rectTextList.push({\r\n                        rect: normalizedRect,\r\n                        text: rect.text,\r\n                        ancestorEl: ancestor,\r\n                        blockAncestorEl: blockAncestor,\r\n                        node: rect.node,\r\n                        startOffset: rect.startOffset\r\n                    });\r\n                });\r\n            }\r\n\r\n            // if range is within one node\r\n            if (rangeInfo && rangeInfo.startNode === rangeInfo.endNode) {\r\n                var node = rangeInfo.startNode;\r\n                var range = that.context.document.createRange();\r\n                range.setStart(node, rangeInfo.startOffset);\r\n                range.setEnd(node, rangeInfo.endOffset);\r\n\r\n                // we are only interested in TEXT_NODE\r\n                if (node.nodeType === Node.TEXT_NODE) {\r\n                    // get client rectangles for the range and push them into rectTextList\r\n                    pushToRectTextList(range);\r\n                    selectedNodes = [];\r\n                }\r\n            }\r\n\r\n            // multi-node range, for each selected node\r\n            _.each(selectedNodes, function(node) {\r\n                // create new Range\r\n                var range = that.context.document.createRange();\r\n                if (node.nodeType === Node.TEXT_NODE) {\r\n                    if (rangeInfo && node === rangeInfo.startNode && rangeInfo.startOffset !== 0) {\r\n                        range.setStart(node, rangeInfo.startOffset);\r\n                        range.setEnd(node, node.length);\r\n                    } else if (rangeInfo && node === rangeInfo.endNode && rangeInfo.endOffset !== 0) {\r\n                        range.setStart(node, 0);\r\n                        range.setEnd(node, rangeInfo.endOffset);\r\n                    } else {\r\n                        range.selectNodeContents(node);\r\n                    }\r\n\r\n                    // for each client rectangle\r\n                    pushToRectTextList(range);\r\n                } else if (node.nodeType === Node.ELEMENT_NODE && includeMedia) {\r\n                    // non-text node element\r\n                    // if we support this elements in the HL group\r\n                    if (_.contains([\"img\", \"video\", \"audio\"], node.tagName.toLowerCase())) {\r\n                        // set the Range to contain the node and its contents and push rectangle to the list\r\n                        range.selectNode(node);\r\n                        rectElementList.push(range.getBoundingClientRect());\r\n                    }\r\n                }\r\n            });\r\n\r\n            var $html = $(that.context.document.documentElement);\r\n\r\n            function calculateScale() {\r\n                var scale = that.scale;\r\n                //is there a transform scale for the content document?\r\n                var matrix = HighlightHelpers.getMatrix($html);\r\n                if (!matrix && (that.context.isIe9 || that.context.isIe10)) {\r\n                    //if there's no transform scale then set the scale as the IE zoom factor\r\n                    scale = (window.screen.deviceXDPI / 96); //96dpi == 100% scale\r\n                } else if (matrix) {\r\n                    scale = HighlightHelpers.getScaleFromMatrix(matrix);\r\n                }\r\n                return scale;\r\n            }\r\n\r\n            var scale = calculateScale();\r\n\r\n            inferrer = new TextLineInferrer({\r\n                lineHorizontalThreshold: $(\"body\", $html).clientWidth,\r\n                lineHorizontalLimit: contentDocumentFrame.contentWindow.innerWidth\r\n            });\r\n\r\n            // only take \"rect\" property when inferring lines\r\n            inferredLines = inferrer.inferLines(rectTextList);\r\n            _.each(inferredLines, function(line, index) {\r\n                var renderData = line.data;\r\n                //console.log(line.data);\r\n                line = line.line;\r\n                var highlightTop = (line.startTop + that.offsetTopAddition) / scale;\r\n                var highlightLeft = (line.left + that.offsetLeftAddition) / scale;\r\n                var highlightHeight = line.avgHeight / scale;\r\n                var highlightWidth = line.width / scale;\r\n                allContainerRects.push({\r\n                    top: highlightTop - hoverThreshold,\r\n                    left: highlightLeft - hoverThreshold,\r\n                    bottom: highlightTop + highlightHeight + hoverThreshold * 2,\r\n                    right: highlightLeft + highlightWidth + hoverThreshold * 2,\r\n                });\r\n\r\n                var highlightView = new HighlightView(that.context, {\r\n                    id: that.id,\r\n                    CFI: that.CFI,\r\n                    type: that.type,\r\n                    top: highlightTop,\r\n                    left: highlightLeft,\r\n                    height: highlightHeight,\r\n                    width: highlightWidth,\r\n                    styles: _.extend({\r\n                        \"z-index\": \"1000\",\r\n                        \"pointer-events\": \"none\"\r\n                    }, highlightStyles),\r\n                    contentRenderData: cloneTextMode ? {\r\n                        data: renderData,\r\n                        top: line.startTop,\r\n                        left: line.left\r\n                    } : null\r\n                });\r\n\r\n                that.highlightViews.push(highlightView);\r\n            });\r\n\r\n            // deal with non TEXT_NODE elements\r\n            _.each(rectElementList, function(rect) {\r\n                var highlightTop = (rect.top + that.offsetTopAddition) / scale;\r\n                var highlightLeft = (rect.left + that.offsetLeftAddition) / scale;\r\n                var highlightHeight = rect.height / scale;\r\n                var highlightWidth = rect.width / scale;\r\n                allContainerRects.push({\r\n                    top: highlightTop - hoverThreshold,\r\n                    left: highlightLeft - hoverThreshold,\r\n                    bottom: highlightTop + highlightHeight + hoverThreshold * 2,\r\n                    right: highlightLeft + highlightWidth + hoverThreshold * 2,\r\n                });\r\n\r\n                var highlightView = new HighlightBorderView(this.context, {\r\n                    highlightId: that.id,\r\n                    CFI: that.CFI,\r\n                    top: highlightTop,\r\n                    left: highlightLeft,\r\n                    height: highlightHeight,\r\n                    width: highlightWidth,\r\n                    styles: highlightStyles\r\n                });\r\n\r\n                that.highlightViews.push(highlightView);\r\n            });\r\n\r\n            // this is a flag indicating if mouse is currently within the boundary of HL group\r\n            var mouseEntered = false;\r\n\r\n            // helper function to test if a point is within a rectangle\r\n            function pointRectangleIntersection(point, rect) {\r\n                return point.x > rect.left && point.x < rect.right &&\r\n                    point.y > rect.top && point.y < rect.bottom;\r\n            };\r\n\r\n            that.boundHighlightCallback = function(e) {\r\n                var scale = calculateScale();\r\n                var mouseIsInside = false;\r\n\r\n                var x = e.pageX;\r\n                var y = e.pageY;\r\n\r\n                if (e.type === 'touchend') {\r\n                    var lastTouch = _.last(e.changedTouches);\r\n                    x = lastTouch.pageX;\r\n                    y = lastTouch.pageY;\r\n                }\r\n\r\n                var point = {\r\n                    x: (x + that.offsetLeftAddition) / scale,\r\n                    y: (y + that.offsetTopAddition) / scale\r\n                };\r\n\r\n                _.each(allContainerRects, function(rect) {\r\n\r\n                    if (pointRectangleIntersection(point, rect)) {\r\n                        mouseIsInside = true;\r\n                        // if event is \"click\" and there is an active selection\r\n                        if (e.type === \"click\") {\r\n                            var sel = e.target.ownerDocument.getSelection();\r\n                            // had to add this check to make sure that rangeCount is not 0\r\n                            if (sel && sel.rangeCount && !sel.getRangeAt(0).collapsed) {\r\n                                //do not trigger a click when there is an active selection\r\n                                return;\r\n                            }\r\n                        }\r\n\r\n                        var isTouchEvent = e.type.indexOf('touch') !== -1;\r\n\r\n                        if (isTouchEvent) {\r\n                            // call \"normal\" event handler for HL group to touch capable devices\r\n                            that.onHighlightEvent(e, e.type);\r\n                        }\r\n\r\n                        // if this is the first time we are mouse entering in the area\r\n                        if (!mouseEntered) {\r\n                            // regardless of the actual event type we want highlightGroupCallback process \"mouseenter\"\r\n                            that.onHighlightEvent(e, \"mouseenter\");\r\n\r\n                            // set flag indicating that we are in HL group confines\r\n                            mouseEntered = true;\r\n                            return;\r\n                        } else if (!isTouchEvent) {\r\n                            // call \"normal\" event handler for HL group to desktop devices\r\n                            that.onHighlightEvent(e, e.type);\r\n                        }\r\n                    }\r\n                });\r\n\r\n                if (!mouseIsInside && mouseEntered) {\r\n                    // set flag indicating that we left HL group confines\r\n                    mouseEntered = false;\r\n                    that.onHighlightEvent(e, \"mouseleave\");\r\n                }\r\n            };\r\n            that.boundHighlightElement = $html;\r\n            $html.on(this.getBoundHighlightContainerEvents(), that.boundHighlightCallback);\r\n        },\r\n\r\n        resetHighlights: function(viewportElement, offsetTop, offsetLeft) {\r\n            this.offsetTopAddition = offsetTop;\r\n            this.offsetLeftAddition = offsetLeft;\r\n            this.destroyCurrentHighlights();\r\n            this.constructHighlightViews();\r\n            this.renderHighlights(viewportElement);\r\n        },\r\n\r\n        destroyCurrentHighlights: function() {\r\n            var that = this;\r\n            _.each(this.highlightViews, function(highlightView) {\r\n                highlightView.remove();\r\n            });\r\n\r\n            var events = that.getBoundHighlightContainerEvents();\r\n            var $el = this.boundHighlightElement;\r\n            if ($el) {\r\n                $el.off(events, this.boundHighlightCallback);\r\n            }\r\n\r\n            this.boundHighlightCallback = null;\r\n            this.boundHighlightElement = null;\r\n\r\n            this.highlightViews.length = 0;\r\n        },\r\n\r\n        renderHighlights: function(viewportElement) {\r\n            // higlight group is live, it just doesn't need to be visible, yet.\r\n            if (!this.visible) {\r\n                return;\r\n            }\r\n\r\n            _.each(this.highlightViews, function(view, index) {\r\n                $(viewportElement).append(view.render());\r\n            });\r\n        },\r\n\r\n        toInfo: function() {\r\n            // get array of rectangles for all the HightligtViews\r\n            var rectangleArray = [];\r\n            var offsetTopAddition = this.offsetTopAddition;\r\n            var offsetLeftAddition = this.offsetLeftAddition;\r\n            var scale = this.scale;\r\n            _.each(this.highlightViews, function(view, index) {\r\n                var hl = view.highlight;\r\n                rectangleArray.push({\r\n                    top: (hl.top - offsetTopAddition) * scale,\r\n                    left: (hl.left - offsetLeftAddition) * scale,\r\n                    height: hl.height * scale,\r\n                    width: hl.width * scale\r\n                });\r\n            });\r\n\r\n            return {\r\n                id: this.id,\r\n                type: this.type,\r\n                CFI: this.CFI,\r\n                rectangleArray: rectangleArray,\r\n                selectedText: this.selectionText\r\n            };\r\n        },\r\n\r\n        setStyles: function(styles) {\r\n            this.styles = styles;\r\n            _.each(this.highlightViews, function(view, index) {\r\n                view.setStyles(styles);\r\n            });\r\n        },\r\n\r\n        update: function(type, styles) {\r\n            this.type = type;\r\n            this.styles = styles;\r\n\r\n            // for each View of the HightlightGroup\r\n            _.each(this.highlightViews, function(view, index) {\r\n                view.update(type, styles);\r\n            });\r\n        },\r\n\r\n        setState: function(state, value) {\r\n            _.each(this.highlightViews, function(view, index) {\r\n                if (state === \"hover\") {\r\n                    if (value) {\r\n                        view.setHoverHighlight();\r\n                    } else {\r\n                        view.setBaseHighlight(false);\r\n                    }\r\n                } else if (state === \"visible\") {\r\n                    view.setVisibility(value);\r\n                } else if (state === \"focused\") {\r\n                    if (value) {\r\n                        view.setFocusedHighlight();\r\n                    } else {\r\n                        view.setBaseHighlight(true);\r\n                    }\r\n\r\n                }\r\n            });\r\n        }\r\n    });\r\n\r\n    return HighlightGroup;\r\n});\r\n\n",
    "define('readium_plugin_highlights/controller',[\"jquery\", \"underscore\", \"./lib/class\", \"./helpers\", \"./models/group\"],\r\nfunction($, _, Class, HighlightHelpers, HighlightGroup) {\r\n    var HighlightsController = Class.extend({\r\n\r\n        highlights: [],\r\n        annotationHash: {},\r\n        offsetTopAddition: 0,\r\n        offsetLeftAddition: 0,\r\n        readerBoundElement: undefined,\r\n        scale: 0,\r\n\r\n        init: function(context, options) {\r\n            this.context = context;\r\n\r\n            this.epubCFI = EPUBcfi;\r\n            this.readerBoundElement = this.context.document.documentElement;\r\n\r\n            if (options.getVisibleCfiRangeFn) {\r\n                this.getVisibleCfiRange = options.getVisibleCfiRangeFn;\r\n            }\r\n\r\n            // inject annotation CSS into iframe\r\n            if (this.context.cssUrl) {\r\n                this._injectAnnotationCSS(this.context.cssUrl);\r\n            }\r\n\r\n            // emit an event when user selects some text.\r\n            var that = this;\r\n            this.context.document.addEventListener(\"mouseup\", function(event) {\r\n                var range = that._getCurrentSelectionRange();\r\n                if (range === undefined) {\r\n                    return;\r\n                }\r\n                if (range.startOffset - range.endOffset) {\r\n                    that.context.manager.trigger(\"textSelectionEvent\", event, range, that.context.iframe);\r\n                }\r\n            });\r\n\r\n            if (!rangy.initialized) {\r\n                rangy.init();\r\n            }\r\n        },\r\n\r\n        getVisibleCfiRange: function() {\r\n            // returns {firstVisibleCfi: <>, lastVisibleCfi: <>}\r\n            // implemented in Readium.ReaderView, passed in via options\r\n        },\r\n\r\n        // ------------------------------------------------------------------------------------ //\r\n        //  \"PUBLIC\" METHODS (THE API)                                                          //\r\n        // ------------------------------------------------------------------------------------ //\r\n\r\n        redraw: function() {\r\n            var that = this;\r\n\r\n            var leftAddition = -this._getPaginationLeftOffset();\r\n            \r\n            var isVerticalWritingMode = this.context.paginationInfo().isVerticalWritingMode;\r\n\r\n            var visibleCfiRange = this.getVisibleCfiRange();\r\n\r\n            // Highlights\r\n            _.each(this.highlights, function(highlightGroup) {\r\n                var visible = true;\r\n\r\n                if (visibleCfiRange &&\r\n                    visibleCfiRange.firstVisibleCfi &&\r\n                    visibleCfiRange.firstVisibleCfi.contentCFI &&\r\n                    visibleCfiRange.lastVisibleCfi &&\r\n                    visibleCfiRange.lastVisibleCfi.contentCFI) {\r\n\r\n                    visible = that._cfiIsBetweenTwoCfis(\r\n                        highlightGroup.CFI,\r\n                        visibleCfiRange.firstVisibleCfi.contentCFI,\r\n                        visibleCfiRange.lastVisibleCfi.contentCFI);\r\n                }\r\n                highlightGroup.visible = visible;\r\n                highlightGroup.resetHighlights(that.readerBoundElement,\r\n                    isVerticalWritingMode ? leftAddition : 0,\r\n                    isVerticalWritingMode ? 0 : leftAddition\r\n                    );\r\n\r\n            });\r\n        },\r\n\r\n        getHighlight: function(id) {\r\n            var highlight = this.annotationHash[id];\r\n            if (highlight) {\r\n                return highlight.toInfo();\r\n            } else {\r\n                return undefined;\r\n            }\r\n        },\r\n\r\n        getHighlights: function() {\r\n            var highlights = [];\r\n            _.each(this.highlights, function(highlight) {\r\n                highlights.push(highlight.toInfo());\r\n            });\r\n            return highlights;\r\n        },\r\n\r\n        removeHighlight: function(annotationId) {\r\n            var annotationHash = this.annotationHash;\r\n            var highlights = this.highlights;\r\n\r\n            delete annotationHash[annotationId];\r\n\r\n            highlights = _.reject(highlights, function(highlightGroup) {\r\n                if (highlightGroup.id == annotationId) {\r\n                    highlightGroup.destroyCurrentHighlights();\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            });\r\n\r\n            this.highlights = highlights;\r\n        },\r\n\r\n        removeHighlightsByType: function(type) {\r\n            var annotationHash = this.annotationHash;\r\n            var highlights = this.highlights;\r\n\r\n            // the returned list only contains HLs for which the function returns false\r\n            highlights = _.reject(highlights, function(highlightGroup) {\r\n                if (highlightGroup.type === type) {\r\n                    delete annotationHash[highlightGroup.id];\r\n                    highlightGroup.destroyCurrentHighlights();\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            });\r\n\r\n            this.highlights = highlights;\r\n        },\r\n\r\n        // generate unique prefix for HL ids\r\n        generateIdPrefix: function() {\r\n            var idPrefix = 'xxxxxxxx'.replace(/[x]/g, function(c) {\r\n                var r = Math.random() * 16 | 0;\r\n                return r.toString(16);\r\n            });\r\n            idPrefix += \"_\";\r\n            return idPrefix;\r\n        },\r\n\r\n\r\n        // takes partial CFI as parameter\r\n        addHighlight: function(CFI, id, type, styles) {\r\n            var CFIRangeInfo;\r\n            var range;\r\n            var rangeStartNode;\r\n            var rangeEndNode;\r\n            var selectedElements;\r\n            var leftAddition;\r\n\r\n            var contentDoc = this.context.document;\r\n            //get transform scale of content document\r\n            var scale = 1.0;\r\n            var matrix = HighlightHelpers.getMatrix($('html', contentDoc));\r\n            if (matrix) {\r\n                scale = HighlightHelpers.getScaleFromMatrix(matrix);\r\n            }\r\n\r\n            //create a dummy test div to determine if the browser provides\r\n            // client rectangles that take transform scaling into consideration\r\n            var $div = $('<div style=\"font-size: 50px; position: absolute; background: red; top:-9001px;\">##</div>');\r\n            $(contentDoc.documentElement).append($div);\r\n            range = contentDoc.createRange();\r\n            range.selectNode($div[0]);\r\n            var renderedWidth = this._normalizeRectangle(range.getBoundingClientRect()).width;\r\n            var clientWidth = $div[0].clientWidth;\r\n            $div.remove();\r\n            var renderedVsClientWidthFactor = renderedWidth / clientWidth;\r\n            if (renderedVsClientWidthFactor === 1) {\r\n                //browser doesn't provide scaled client rectangles (firefox)\r\n                scale = 1;\r\n            } else if (this.context.isIe9 || this.context.isIe10) {\r\n                //use the test scale factor as our scale value for IE 9/10\r\n                scale = renderedVsClientWidthFactor;\r\n            }\r\n            this.scale = scale;\r\n\r\n            // form fake full CFI to satisfy getRangeTargetNodes\r\n            var arbitraryPackageDocCFI = \"/99!\"\r\n            var fullFakeCFI = \"epubcfi(\" + arbitraryPackageDocCFI + CFI + \")\";\r\n            if (this.epubCFI.Interpreter.isRangeCfi(fullFakeCFI)) {\r\n                CFIRangeInfo = this.epubCFI.getRangeTargetElements(fullFakeCFI, contentDoc, [\"cfi-marker\", \"cfi-blacklist\", \"mo-cfi-highlight\"], [], [\"MathJax_Message\", \"MathJax_SVG_Hidden\"]);\r\n\r\n                var startNode = CFIRangeInfo.startElement,\r\n                    endNode = CFIRangeInfo.endElement;\r\n                range = rangy.createRange(contentDoc);\r\n                if (startNode.length < CFIRangeInfo.startOffset) {\r\n                    //this is a workaround\r\n                    // \"Uncaught IndexSizeError: Index or size was negative, or greater than the allowed value.\" errors\r\n                    // the range cfi generator outputs a cfi like /4/2,/1:125,/16\r\n                    // can't explain, investigating..\r\n                    CFIRangeInfo.startOffset = startNode.length;\r\n                }\r\n                range.setStart(startNode, CFIRangeInfo.startOffset);\r\n                range.setEnd(endNode, CFIRangeInfo.endOffset);\r\n                selectedElements = range.getNodes();\r\n            } else {\r\n                var element = this.epubCFI.getTargetElement(fullFakeCFI, contentDoc, [\"cfi-marker\", \"cfi-blacklist\", \"mo-cfi-highlight\"], [], [\"MathJax_Message\", \"MathJax_SVG_Hidden\"]);\r\n                selectedElements = [element ? element[0] : null];\r\n                range = null;\r\n            }\r\n\r\n            leftAddition = -this._getPaginationLeftOffset();\r\n\r\n            var isVerticalWritingMode = this.context.paginationInfo().isVerticalWritingMode;\r\n\r\n            this._addHighlightHelper(\r\n                CFI, id, type, styles, selectedElements, range,\r\n                startNode, endNode,\r\n                isVerticalWritingMode ? leftAddition : 0,\r\n                isVerticalWritingMode ? 0 : leftAddition\r\n                );\r\n\r\n            return {\r\n                selectedElements: selectedElements,\r\n                CFI: CFI\r\n            };\r\n        },\r\n\r\n\r\n        // this returns a partial CFI only!!\r\n        getCurrentSelectionCFI: function() {\r\n            var currentSelection = this._getCurrentSelectionRange();\r\n            var CFI;\r\n            if (currentSelection) {\r\n                selectionInfo = this._getSelectionInfo(currentSelection);\r\n                CFI = selectionInfo.CFI;\r\n            }\r\n\r\n            return CFI;\r\n        },\r\n\r\n        // this returns a partial CFI only!!\r\n        getCurrentSelectionOffsetCFI: function() {\r\n            var currentSelection = this._getCurrentSelectionRange();\r\n\r\n            var CFI;\r\n            if (currentSelection) {\r\n                CFI = this._generateCharOffsetCFI(currentSelection);\r\n            }\r\n            return CFI;\r\n        },\r\n\r\n        addSelectionHighlight: function(id, type, styles, clearSelection) {\r\n            var CFI = this.getCurrentSelectionCFI();\r\n            if (CFI) {\r\n\r\n                // if clearSelection is true\r\n                if (clearSelection) {\r\n                    var iframeDocument = this.context.document;\r\n                    if (iframeDocument.getSelection) {\r\n                        var currentSelection = iframeDocument.getSelection();\r\n                        currentSelection.collapseToStart();\r\n                    }\r\n                }\r\n                return this.addHighlight(CFI, id, type, styles);\r\n            } else {\r\n                throw new Error(\"Nothing selected\");\r\n            }\r\n        },\r\n\r\n        updateAnnotation: function(id, type, styles) {\r\n            var annotationViews = this.annotationHash[id];\r\n            if (annotationViews) {\r\n                annotationViews.update(type, styles);\r\n            }\r\n            return annotationViews;\r\n        },\r\n\r\n        replaceAnnotation: function(id, cfi, type, styles) {\r\n            var annotationViews = this.annotationHash[id];\r\n            if (annotationViews) {\r\n                // remove an existing annotatio\r\n                this.removeHighlight(id);\r\n\r\n                // create a new HL\r\n                this.addHighlight(cfi, id, type, styles);\r\n            }\r\n            return annotationViews;\r\n        },\r\n\r\n        updateAnnotationView: function(id, styles) {\r\n            var annotationViews = this.annotationHash[id];\r\n            if (annotationViews) {\r\n                annotationViews.setStyles(styles);\r\n            }\r\n            return annotationViews;\r\n        },\r\n\r\n        setAnnotationViewState: function(id, state, value) {\r\n            var annotationViews = this.annotationHash[id];\r\n            if (annotationViews) {\r\n                annotationViews.setState(state, value);\r\n            }\r\n            return annotationViews;\r\n        },\r\n\r\n        setAnnotationViewStateForAll: function(state, value) {\r\n            var annotationViews = this.annotationHash;\r\n            _.each(annotationViews, function(annotationView) {\r\n                annotationView.setState(state, value);\r\n            });\r\n        },\r\n\r\n        // ------------------------------------------------------------------------------------ //\r\n        //  \"PRIVATE\" HELPERS                                                                   //\r\n        // ------------------------------------------------------------------------------------ //\r\n\r\n\r\n\r\n        //return an array of all numbers in the content cfi\r\n        _parseContentCfi: function(cont) {\r\n            return cont.replace(/\\[(.*?)\\]/, \"\").split(/[\\/,:]/).map(function(n) {\r\n                return parseInt(n);\r\n            }).filter(Boolean);\r\n        },\r\n\r\n        _contentCfiComparator: function(cont1, cont2) {\r\n            cont1 = this._parseContentCfi(cont1);\r\n            cont2 = this._parseContentCfi(cont2);\r\n\r\n            //compare cont arrays looking for differences\r\n            for (var i = 0; i < cont1.length; i++) {\r\n                if (cont1[i] > cont2[i]) {\r\n                    return 1;\r\n                } else if (cont1[i] < cont2[i]) {\r\n                    return -1;\r\n                }\r\n            }\r\n\r\n            //no differences found, so confirm that cont2 did not have values we didn't check\r\n            if (cont1.length < cont2.length) {\r\n                return -1;\r\n            }\r\n\r\n            //cont arrays are identical\r\n            return 0;\r\n        },\r\n\r\n        // determine if a given Cfi falls between two other cfis.2\r\n        _cfiIsBetweenTwoCfis: function(cfi, firstVisibleCfi, lastVisibleCfi) {\r\n            if (!firstVisibleCfi || !lastVisibleCfi) {\r\n                return null;\r\n            }\r\n            var first = this._contentCfiComparator(cfi, firstVisibleCfi);\r\n            var second = this._contentCfiComparator(cfi, lastVisibleCfi);\r\n            return first >= 0 && second <= 0;\r\n        },\r\n\r\n        _addHighlightHelper: function(CFI, annotationId, type, styles, highlightedNodes,\r\n            range, startNode, endNode, offsetTop, offsetLeft) {\r\n            if (!offsetTop) {\r\n                offsetTop = this.offsetTopAddition;\r\n            }\r\n            if (!offsetLeft) {\r\n                offsetLeft = this.offsetLeftAddition;\r\n            }\r\n\r\n            var visible;\r\n            // check if the options specify lastVisibleCfi/firstVisibleCfi. If they don't fall back to displaying the highlights anyway.\r\n            var visibleCfiRange = this.getVisibleCfiRange();\r\n            if (visibleCfiRange &&\r\n                visibleCfiRange.firstVisibleCfi &&\r\n                visibleCfiRange.firstVisibleCfi.contentCFI &&\r\n                visibleCfiRange.lastVisibleCfi &&\r\n                visibleCfiRange.lastVisibleCfi.contentCFI) {\r\n                visible = this._cfiIsBetweenTwoCfis(CFI, visibleCfiRange.firstVisibleCfi.contentCFI, visibleCfiRange.lastVisibleCfi.contentCFI);\r\n            } else {\r\n                visible = true;\r\n            }\r\n\r\n            annotationId = annotationId.toString();\r\n            if (this.annotationHash[annotationId]) {\r\n                throw new Error(\"That annotation id already exists; annotation not added\");\r\n            }\r\n\r\n            var highlightGroup = new HighlightGroup(this.context, {\r\n                CFI: CFI,\r\n                selectedNodes: highlightedNodes,\r\n                offsetTopAddition: offsetTop,\r\n                offsetLeftAddition: offsetLeft,\r\n                styles: styles,\r\n                id: annotationId,\r\n                type: type,\r\n                scale: this.scale,\r\n                selectionText: range ? range.toString() : \"\",\r\n                visible: visible,\r\n                rangeInfo: range ? {\r\n                    startNode: startNode,\r\n                    startOffset: range.startOffset,\r\n                    endNode: endNode,\r\n                    endOffset: range.endOffset\r\n                } : null\r\n            });\r\n\r\n            this.annotationHash[annotationId] = highlightGroup;\r\n            this.highlights.push(highlightGroup);\r\n\r\n\r\n            highlightGroup.renderHighlights(this.readerBoundElement);\r\n        },\r\n\r\n        _normalizeRectangle: function(rect) {\r\n            return {\r\n                left: rect.left,\r\n                right: rect.right,\r\n                top: rect.top,\r\n                bottom: rect.bottom,\r\n                width: rect.right - rect.left,\r\n                height: rect.bottom - rect.top\r\n            };\r\n        },\r\n\r\n        _getSelectionInfo: function(selectedRange, elementType) {\r\n            // Generate CFI for selected text\r\n            var CFI = this._generateRangeCFI(selectedRange);\r\n            var intervalState = {\r\n                startElementFound: false,\r\n                endElementFound: false\r\n            };\r\n            var selectedElements = [];\r\n\r\n            if (!elementType) {\r\n                var elementType = [\"text\"];\r\n            }\r\n\r\n            this._findSelectedElements(\r\n                selectedRange.commonAncestorContainer,\r\n                selectedRange.startContainer,\r\n                selectedRange.endContainer,\r\n                intervalState,\r\n                selectedElements,\r\n                elementType\r\n            );\r\n\r\n            // Return a list of selected text nodes and the CFI\r\n            return {\r\n                CFI: CFI,\r\n                selectedElements: selectedElements\r\n            };\r\n        },\r\n\r\n        _generateRangeCFI: function(selectedRange) {\r\n            var startNode = selectedRange.startContainer;\r\n            var endNode = selectedRange.endContainer;\r\n            var commonAncestor = selectedRange.commonAncestorContainer;\r\n            var startOffset;\r\n            var endOffset;\r\n            var rangeCFIComponent;\r\n\r\n            startOffset = selectedRange.startOffset;\r\n            endOffset = selectedRange.endOffset;\r\n\r\n            rangeCFIComponent = this.epubCFI.generateRangeComponent(\r\n                startNode,\r\n                startOffset,\r\n                endNode,\r\n                endOffset, [\"cfi-marker\", \"cfi-blacklist\", \"mo-cfi-highlight\"], [], [\"MathJax_Message\", \"MathJax_SVG_Hidden\"]\r\n            );\r\n            return rangeCFIComponent;\r\n        },\r\n\r\n        _generateCharOffsetCFI: function(selectedRange) {\r\n            // Character offset\r\n            var startNode = selectedRange.startContainer;\r\n            var startOffset = selectedRange.startOffset;\r\n            var charOffsetCFI;\r\n\r\n            if (startNode.nodeType === Node.TEXT_NODE) {\r\n                charOffsetCFI = this.epubCFI.generateCharacterOffsetCFIComponent(\r\n                    startNode,\r\n                    startOffset, [\"cfi-marker\", \"cfi-blacklist\", \"mo-cfi-highlight\"], [], [\"MathJax_Message\", \"MathJax_SVG_Hidden\"]\r\n                );\r\n            }\r\n            return charOffsetCFI;\r\n        },\r\n\r\n        // REFACTORING CANDIDATE: Convert this to jquery\r\n        _findSelectedElements: function(\r\n            currElement, startElement, endElement, intervalState, selectedElements, elementTypes) {\r\n\r\n            if (currElement === startElement) {\r\n                intervalState.startElementFound = true;\r\n            }\r\n\r\n            if (intervalState.startElementFound === true) {\r\n                this._addElement(currElement, selectedElements, elementTypes);\r\n            }\r\n\r\n            if (currElement === endElement) {\r\n                intervalState.endElementFound = true;\r\n                return;\r\n            }\r\n\r\n            if (currElement.firstChild) {\r\n                this._findSelectedElements(currElement.firstChild, startElement, endElement,\r\n                    intervalState, selectedElements, elementTypes);\r\n                if (intervalState.endElementFound) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (currElement.nextSibling) {\r\n                this._findSelectedElements(currElement.nextSibling, startElement, endElement,\r\n                    intervalState, selectedElements, elementTypes);\r\n                if (intervalState.endElementFound) {\r\n                    return;\r\n                }\r\n            }\r\n        },\r\n\r\n        _addElement: function(currElement, selectedElements, elementTypes) {\r\n            // Check if the node is one of the types\r\n            _.each(elementTypes, function(elementType) {\r\n\r\n                if (elementType === \"text\") {\r\n                    if (currElement.nodeType === Node.TEXT_NODE) {\r\n                        selectedElements.push(currElement);\r\n                    }\r\n                } else {\r\n                    if ($(currElement).is(elementType)) {\r\n                        selectedElements.push(currElement);\r\n                    }\r\n                }\r\n            });\r\n        },\r\n\r\n        // Rationale: This is a cross-browser method to get the currently selected text\r\n        _getCurrentSelectionRange: function() {\r\n            var currentSelection;\r\n            var iframeDocument = this.context.document;\r\n            if (iframeDocument.getSelection) {\r\n\r\n                currentSelection = iframeDocument.getSelection();\r\n                if (!currentSelection || currentSelection.rangeCount === 0) {\r\n                    return undefined;\r\n                }\r\n\r\n                var range = currentSelection.getRangeAt(0);\r\n\r\n                if (range.toString() !== '') {\r\n                    return range;\r\n                } else {\r\n                    return undefined;\r\n                }\r\n            } else if (iframeDocument.selection) {\r\n                return iframeDocument.selection.createRange();\r\n            } else {\r\n                return undefined;\r\n            }\r\n        },\r\n\r\n        _getPaginationLeftOffset: function() {\r\n        \r\n            var $htmlElement = $(this.context.document.documentElement);\r\n            if (!$htmlElement || !$htmlElement.length) {\r\n                // if there is no html element, we might be dealing with a fxl with a svg spine item\r\n                return 0;\r\n            }\r\n\r\n            var offsetLeftPixels = $htmlElement.css(this.context.paginationInfo().isVerticalWritingMode ? \"top\" : (this.context.isRTL ? \"right\" : \"left\"));\r\n            var offsetLeft = parseInt(offsetLeftPixels.replace(\"px\", \"\"));\r\n            if (isNaN(offsetLeft)) {\r\n                //for fixed layouts, $htmlElement.css(\"left\") has no numerical value\r\n                offsetLeft = 0;\r\n            }\r\n            \r\n            if (this.context.isRTL && !this.context.paginationInfo().isVerticalWritingMode) return -offsetLeft;\r\n             \r\n            return offsetLeft;\r\n        },\r\n\r\n        _injectAnnotationCSS: function(annotationCSSUrl) {\r\n            var doc = this.context.document;\r\n            setTimeout(function(){\r\n                var $contentDocHead = $(\"head\", doc);\r\n                $contentDocHead.append(\r\n                    $(\"<link/>\", {\r\n                        rel: \"stylesheet\",\r\n                        href: annotationCSSUrl,\r\n                        type: \"text/css\"\r\n                    })\r\n                );\r\n            }, 0);\r\n        }\r\n    });\r\n\r\n    return HighlightsController;\r\n});\r\n\n",
    "//  Created by Dmitry Markushevich (dmitrym@evidentpoint.com)\r\n//\r\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\r\n//\r\n//  Redistribution and use in source and binary forms, with or without modification,\r\n//  are permitted provided that the following conditions are met:\r\n//  1. Redistributions of source code must retain the above copyright notice, this\r\n//  list of conditions and the following disclaimer.\r\n//  2. Redistributions in binary form must reproduce the above copyright notice,\r\n//  this list of conditions and the following disclaimer in the documentation and/or\r\n//  other materials provided with the distribution.\r\n//  3. Neither the name of the organization nor the names of its contributors may be\r\n//  used to endorse or promote products derived from this software without specific\r\n//  prior written permission.\r\n//\r\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\r\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\r\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\r\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\ndefine('readium_plugin_highlights/manager',['jquery', 'underscore', 'eventEmitter', './controller', './helpers', 'readium_shared_js/models/bookmark_data'], function($, _, EventEmitter, HighlightsController, HighlightHelpers, BookmarkData) {\r\n\r\nvar defaultContext = {};\r\n\r\n//determine if browser is IE9 or IE10\r\nvar div = document.createElement(\"div\");\r\ndiv.innerHTML = \"<!--[if IE 9]><i></i><![endif]-->\";\r\ndefaultContext.isIe9 = (div.getElementsByTagName(\"i\").length == 1);\r\n// IE10 introduced a prefixed version of PointerEvent, but not unprefixed.\r\ndefaultContext.isIe10 = window.MSPointerEvent && !window.PointerEvent;\r\n\r\n/**\r\n *\r\n * @param proxyObj\r\n * @param options\r\n * @constructor\r\n */\r\nvar HighlightsManager = function (proxyObj, options) {\r\n\r\n    var self = this;\r\n\r\n    // live annotations contains references to the annotation _module_ for visible spines\r\n    var liveAnnotations = {};\r\n    var spines = {};\r\n    var proxy = proxyObj;\r\n    var annotationCSSUrl = options.annotationCSSUrl;\r\n\r\n    if (!annotationCSSUrl) {\r\n        console.warn(\"WARNING! Annotations CSS not supplied. Highlighting might not work.\");\r\n    }\r\n\r\n    _.extend(this, new EventEmitter());\r\n\r\n    // this.on(\"all\", function() {\r\n    // });\r\n    //TODO: EventEmitter3 does not support \"all\" or \"*\" (catch-all event sink)\r\n    //https://github.com/primus/eventemitter3/blob/master/index.js#L61\r\n    //...so instead we patch trigger() and emit() (which are synonymous, see Bootstrapper.js EventEmitter.prototype.trigger = EventEmitter.prototype.emit;)\r\n\r\n    var originalEmit = self['emit'];\r\n\r\n    var triggerEmitPatch = function() {\r\n        var args = Array.prototype.slice.call(arguments);\r\n        // mangle annotationClicked event. What really needs to happen is, the annotation_module needs to return a\r\n        // bare Cfi, and this class should append the idref.\r\n        var mangleEvent = function(annotationEvent){\r\n            if (args.length && args[0] === annotationEvent) {\r\n                for (var spineIndex in liveAnnotations)\r\n                {\r\n                    var contentDocumentFrame = args[5];\r\n                    var jQueryEvent = args[4];\r\n                    if (typeof jQueryEvent.clientX === 'undefined') {\r\n                        jQueryEvent.clientX = jQueryEvent.pageX;\r\n                        jQueryEvent.clientY = jQueryEvent.pageY;\r\n                    }\r\n\r\n                    var annotationId = args[3];\r\n                    var partialCfi = args[2];\r\n                    var type = args[1];\r\n                    if (liveAnnotations[spineIndex].getHighlight(annotationId)) {\r\n                        var idref = spines[spineIndex].idref;\r\n                        args = [annotationEvent, type, idref, partialCfi, annotationId, jQueryEvent, contentDocumentFrame];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        mangleEvent('annotationClicked');\r\n        mangleEvent('annotationTouched');\r\n        mangleEvent('annotationRightClicked');\r\n        mangleEvent('annotationHoverIn');\r\n        mangleEvent('annotationHoverOut');\r\n\r\n        originalEmit.apply(this, args);\r\n        originalEmit.apply(proxy, args);\r\n    };\r\n\r\n    this.trigger = triggerEmitPatch;\r\n    this.emit = triggerEmitPatch;\r\n\r\n    this.attachAnnotations = function($iframe, spineItem, loadedSpineItems) {\r\n        var iframe = $iframe[0];\r\n\r\n        var context = _.extend({\r\n            document: iframe.contentDocument,\r\n            window: iframe.contentWindow,\r\n            iframe: iframe,\r\n            manager: self,\r\n            cssUrl: annotationCSSUrl,\r\n            isFixedLayout: spineItem.isFixedLayout(),\r\n            isRTL: spineItem.spine.isRightToLeft(),\r\n            paginationInfo: function() { return spineItem.paginationInfo; }\r\n            \r\n        }, defaultContext);\r\n\r\n        liveAnnotations[spineItem.index] = new HighlightsController(context, {getVisibleCfiRangeFn: options.getVisibleCfiRangeFn});\r\n        spines[spineItem.index] = spineItem;\r\n\r\n        // check to see which spine indicies can be culled depending on the currently loaded spine items\r\n        for(var spineIndex in liveAnnotations) {\r\n            if (liveAnnotations.hasOwnProperty(spineIndex) && !_.contains(loadedSpineItems, spines[spineIndex])) {\r\n                delete liveAnnotations[spineIndex];\r\n            }\r\n        }\r\n    };\r\n\r\n    this.getCurrentSelectionCfi = function() {\r\n        for(var spine in liveAnnotations) {\r\n            var annotationsForView = liveAnnotations[spine];\r\n            var partialCfi = annotationsForView.getCurrentSelectionCFI();\r\n            if (partialCfi) {\r\n                return {\"idref\":spines[spine].idref, \"cfi\":partialCfi};\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    this.addSelectionHighlight = function(id, type, clearSelection, styles) {\r\n        for(var spine in liveAnnotations) {\r\n            var annotationsForView = liveAnnotations[spine];\r\n            if (annotationsForView.getCurrentSelectionCFI()) {\r\n                var annotation = annotationsForView.addSelectionHighlight(\r\n                    id, type, clearSelection, styles);\r\n                return new BookmarkData(spines[spine].idref, annotation.CFI);\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    this.addHighlight = function(spineIdRef, partialCfi, id, type, styles) {\r\n        for(var spine in liveAnnotations) {\r\n            if (spines[spine].idref === spineIdRef) {\r\n                var annotationsForView = liveAnnotations[spine];\r\n                var annotation = annotationsForView.addHighlight(partialCfi, id, type, styles);\r\n                if (annotation) {\r\n                    return new BookmarkData(spineIdRef, annotation.CFI);\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n\r\n    this.removeHighlight = function(id) {\r\n        var result = undefined;\r\n        for(var spine in liveAnnotations) {\r\n            var annotationsForView = liveAnnotations[spine];\r\n            result  = annotationsForView.removeHighlight(id);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    this.removeHighlightsByType = function(type) {\r\n        var result = undefined;\r\n        for(var spine in liveAnnotations) {\r\n            var annotationsForView = liveAnnotations[spine];\r\n            result  = annotationsForView.removeHighlightsByType(type);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    this.getHighlight = function(id) {\r\n        var result = undefined;\r\n        for(var spine in liveAnnotations) {\r\n            var annotationsForView = liveAnnotations[spine];\r\n            result  = annotationsForView.getHighlight(id);\r\n            if (result !== undefined)\r\n\t\t\t\treturn result;\r\n        }\r\n        return result;\r\n    };\r\n\r\n    this.updateAnnotation = function(id, type, styles) {\r\n        var result = undefined;\r\n        for(var spine in liveAnnotations) {\r\n            var annotationsForView = liveAnnotations[spine];\r\n            result = annotationsForView.updateAnnotation(id, type, styles);\r\n            if(result) {\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    this.replaceAnnotation = function(id, cfi, type, styles) {\r\n        var result = undefined;\r\n        for(var spine in liveAnnotations) {\r\n            var annotationsForView = liveAnnotations[spine];\r\n            result = annotationsForView.replaceAnnotation(id, cfi, type, styles);\r\n            if(result) {\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    // redraw gets called on pagination change, so for progressive rendering we may have to add annotations that were previously not visible.\r\n    this.redrawAnnotations = function(){\r\n        for(var spine in liveAnnotations) {\r\n            liveAnnotations[spine].redraw();\r\n        }\r\n    };\r\n\r\n    this.updateAnnotationView = function(id, styles) {\r\n        var result = undefined;\r\n        for(var spine in liveAnnotations) {\r\n            var annotationsForView = liveAnnotations[spine];\r\n            result = annotationsForView.updateAnnotationView(id,styles);\r\n            if(result){\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    this.setAnnotationViewState = function(id, state, value) {\r\n        var result = undefined;\r\n        for(var spine in liveAnnotations) {\r\n            var annotationsForView = liveAnnotations[spine];\r\n            result = annotationsForView.setAnnotationViewState(id, state, value);\r\n            if(result){\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    this.setAnnotationViewStateForAll = function(state, value) {\r\n        var result = undefined;\r\n        for(var spine in liveAnnotations) {\r\n            var annotationsForView = liveAnnotations[spine];\r\n            result = annotationsForView.setAnnotationViewStateForAll(state, value);\r\n            if(result){\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    this.cfiIsBetweenTwoCfis = function (cfi, lowBoundaryCfi, highBoundaryCfi) {\r\n        var result = undefined;\r\n        for(var spine in liveAnnotations) {\r\n            var annotationsForView = liveAnnotations[spine];\r\n            result = annotationsForView.cfiIsBetweenTwoCfis(cfi, lowBoundaryCfi, highBoundaryCfi);\r\n            if(result){\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    this.contentCfiComparator = function(contCfi1, contCfi2) {\r\n        var result = undefined;\r\n        for(var spine in liveAnnotations) {\r\n            var annotationsForView = liveAnnotations[spine];\r\n            result = annotationsForView.contentCfiComparator(contCfi1, contCfi2);\r\n            if(result){\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n    function getElementFromViewElement(element) {\r\n        //TODO JC: yuck, we get two different collection structures from non fixed and fixed views.. must refactor..\r\n        return element.element ? element.element : element;\r\n    }\r\n\r\n    this.getAnnotationMidpoints = function($elementSpineItemCollection){\r\n        var output = [];\r\n\r\n        _.each($elementSpineItemCollection, function (item){\r\n            var annotations = [];\r\n\r\n            var lastId = null;\r\n\r\n            var baseOffset = {top: 0, left: 0};\r\n            if (item.elements && item.elements.length > 0) {\r\n                var firstElement = getElementFromViewElement(item.elements[0]);\r\n                var offsetElement = firstElement.ownerDocument.defaultView.frameElement.parentElement;\r\n                baseOffset = {top: offsetElement.offsetTop, left: offsetElement.offsetLeft};\r\n            }\r\n\r\n            _.each(item.elements, function(element){\r\n\r\n                var $element = $(getElementFromViewElement(element));\r\n                var elementId = $element.attr('data-id');\r\n\r\n                if(!elementId){\r\n                    console.warn('AnnotationsManager:getAnnotationMidpoints: Got an annotation element with no ID??')\r\n                    return;\r\n                }\r\n                if (elementId === lastId) return;\r\n                lastId = elementId;\r\n\r\n                //calculate position offsets with scaling\r\n                var scale = 1;\r\n                //figure out a better way to get the html parent from an element..\r\n                var $html = $element.parent();\r\n                //get transformation scale from content document\r\n                var matrix = HighlightHelpers.getMatrix($html);\r\n                if (matrix) {\r\n                    scale = HighlightHelpers.getScaleFromMatrix(matrix);\r\n                }\r\n                var offset = $element.offset();\r\n                offset.top += baseOffset.top + ($element.height() / 2);\r\n                offset.left += baseOffset.left;\r\n                if(scale !== 1){\r\n                    offset = {top: (offset.top * scale)*(1/scale), left: offset.left };\r\n                }\r\n                var $highlighted = {id: elementId, position: offset, lineHeight: parseInt($element.css('line-height'),10)};\r\n                annotations.push($highlighted)\r\n            });\r\n\r\n            output.push({annotations:annotations, spineItem: item.spineItem});\r\n        });\r\n\r\n        return output;\r\n    };\r\n\r\n    this.getAnnotationsElementSelector = function () {\r\n        return 'div.rd-highlight, div.rd-highlight-border';\r\n    };\r\n\r\n};\r\n\r\nreturn HighlightsManager;\r\n});\r\n\n",
    "define('readium_plugin_highlights/main',['readium_js_plugins', 'readium_shared_js/globals', './manager'], function (Plugins, Globals, HighlightsManager) {\r\n    var config = {};\r\n\r\n    Plugins.register(\"highlights\", function (api) {\r\n        var reader = api.reader, _highlightsManager, _initialized = false, _initializedLate = false;\r\n\r\n        var self = this;\r\n\r\n        function isInitialized() {\r\n            if (!_initialized) {\r\n                api.plugin.warn('Not initialized!')\r\n            }\r\n            return _initialized;\r\n        }\r\n\r\n        this.initialize = function (options) {\r\n            options = options || {};\r\n\r\n            setTimeout(isInitialized, 1000);\r\n\r\n            if (_initialized) {\r\n                api.plugin.warn('Already initialized!');\r\n                return;\r\n            }\r\n\r\n            if (reader.getFirstVisibleCfi && reader.getLastVisibleCfi && !options.getVisibleCfiRangeFn) {\r\n                options.getVisibleCfiRangeFn = function () {\r\n                    return {firstVisibleCfi: reader.getFirstVisibleCfi(), lastVisibleCfi: reader.getLastVisibleCfi()};\r\n                };\r\n            }\r\n\r\n            _highlightsManager = new HighlightsManager(self, options);\r\n\r\n            if (_initializedLate) {\r\n                api.plugin.warn('Unable to attach to currently loaded content document.\\n' +\r\n                'Initialize the plugin before loading a content document.');\r\n            }\r\n\r\n            _initialized = true;\r\n        };\r\n\r\n        this.getHighlightsManager = function() {\r\n            return _highlightsManager;\r\n        };\r\n\r\n        /**\r\n         * Returns current selection partial Cfi, useful for workflows that need to check whether the user has selected something.\r\n         *\r\n         * @returns {object | undefined} partial cfi object or undefined if nothing is selected\r\n         */\r\n        this.getCurrentSelectionCfi = function() {\r\n            return _highlightsManager.getCurrentSelectionCfi();\r\n        };\r\n\r\n        /**\r\n         * Creates a higlight based on given parameters\r\n         *\r\n         * @param {string} spineIdRef\t\tSpine idref that defines the partial Cfi\r\n         * @param {string} cfi\t\t\t\tPartial CFI (withouth the indirection step) relative to the spine index\r\n         * @param {string} id\t\t\t\tId of the highlight. must be unique\r\n         * @param {string} type \t\t\tName of the class selector rule in annotations stylesheet.\r\n         * \t\t\t\t\t\t\t\t\tThe style of the class will be applied to the created hightlight\r\n         * @param {object} styles\t\t\tObject representing CSS properties to be applied to the highlight.\r\n         * \t\t\t\t\t\t\t\t\te.g., to apply background color pass in: {'background-color': 'green'}\r\n         *\r\n         * @returns {object | undefined} partial cfi object of the created highlight\r\n         */\r\n        this.addHighlight = function(spineIdRef, cfi, id, type, styles) {\r\n            return _highlightsManager.addHighlight(spineIdRef, cfi, id, type, styles);\r\n        };\r\n\r\n        /**\r\n         * Creates a higlight based on the current selection\r\n         *\r\n         * @param {string} id id of the highlight. must be unique\r\n         * @param {string} type - name of the class selector rule in annotations.css file.\r\n         * @param {boolean} clearSelection - set to true to clear the current selection\r\n         * after it is highlighted\r\n         * The style of the class will be applied to the created hightlight\r\n         * @param {object} styles - object representing CSS properties to be applied to the highlight.\r\n         * e.g., to apply background color pass this {'background-color': 'green'}\r\n         *\r\n         * @returns {object | undefined} partial cfi object of the created highlight\r\n         */\r\n        this.addSelectionHighlight =  function(id, type, styles, clearSelection) {\r\n            return _highlightsManager.addSelectionHighlight(id, type, styles, clearSelection);\r\n        };\r\n\r\n        /**\r\n         * Removes a given highlight\r\n         *\r\n         * @param {string} id  The id associated with the highlight.\r\n         *\r\n         * @returns {undefined}\r\n         *\r\n         */\r\n        this.removeHighlight = function(id) {\r\n            return _highlightsManager.removeHighlight(id);\r\n        };\r\n\r\n        /**\r\n         * Removes highlights of a given type\r\n         *\r\n         * @param {string} type type of the highlight.\r\n         *\r\n         * @returns {undefined}\r\n         *\r\n         */\r\n        this.removeHighlightsByType = function(type) {\r\n            return _highlightsManager.removeHighlightsByType(type);\r\n        };\r\n\r\n        /**\r\n         * Client Rectangle\r\n         * @typedef {object} ReadiumSDK.Views.ReaderView.ClientRect\r\n         * @property {number} top\r\n         * @property {number} left\r\n         * @property {number} height\r\n         * @property {number} width\r\n         */\r\n\r\n        /**\r\n         * Highlight Info\r\n         *\r\n         * @typedef {object} ReadiumSDK.Views.ReaderView.HighlightInfo\r\n         * @property {string} id - unique id of the highlight\r\n         * @property {string} type - highlight type (css class)\r\n         * @property {string} CFI - partial CFI range of the highlight\r\n         * @property {ReadiumSDK.Views.ReaderView.ClientRect[]} rectangleArray - array of rectangles consituting the highlight\r\n         * @property {string} selectedText - concatenation of highlight nodes' text\r\n         */\r\n\r\n        /**\r\n         * Gets given highlight\r\n         *\r\n         * @param {string} id id of the highlight.\r\n         *\r\n         * @returns {ReadiumSDK.Views.ReaderView.HighlightInfo} Object describing the highlight\r\n         */\r\n        this.getHighlight = function(id) {\r\n            return _highlightsManager.getHighlight(id);\r\n        };\r\n\r\n        /**\r\n         * Update annotation by the id, reapplies CSS styles to the existing annotaion\r\n         *\r\n         * @param {string} id id of the annotation.\r\n         * @property {string} type - annotation type (name of css class)\r\n         * @param {object} styles - object representing CSS properties to be applied to the annotation.\r\n         * e.g., to apply background color pass this {'background-color': 'green'}.\r\n         */\r\n        this.updateAnnotation = function(id, type, styles) {\r\n            _highlightsManager.updateAnnotation(id, type, styles);\r\n        };\r\n\r\n        /**\r\n         * Replace annotation with this id. Current annotation is removed and a new one is created.\r\n         *\r\n         * @param {string} id id of the annotation.\r\n         * @property {string} cfi - partial CFI range of the annotation\r\n         * @property {string} type - annotation type (name of css class)\r\n         * @param {object} styles - object representing CSS properties to be applied to the annotation.\r\n         * e.g., to apply background color pass this {'background-color': 'green'}.\r\n         */\r\n        this.replaceAnnotation = function(id, cfi, type, styles) {\r\n            _highlightsManager.replaceAnnotation(id, cfi, type, styles);\r\n        };\r\n\r\n\r\n        /**\r\n         * Redraws all annotations\r\n         */\r\n        this.redrawAnnotations = function() {\r\n            _highlightsManager.redrawAnnotations();\r\n        };\r\n\r\n        /**\r\n         * Updates an annotation to use the supplied styles\r\n         *\r\n         * @param {string} id\r\n         * @param {string} styles\r\n         */\r\n        this.updateAnnotationView = function(id, styles) {\r\n            _highlightsManager.updateAnnotationView(id, styles);\r\n        };\r\n\r\n        /**\r\n         * Updates an annotation view state, such as whether its hovered in or not.\r\n         * @param {string} id       The id associated with the highlight.\r\n         * @param {string} state    The state type to be updated\r\n         * @param {string} value    The state value to apply to the highlight\r\n         * @returns {undefined}\r\n         */\r\n        this.setAnnotationViewState = function(id, state, value) {\r\n            return _highlightsManager.setAnnotationViewState(id, state, value);\r\n        };\r\n\r\n        /**\r\n         * Updates an annotation view state for all views.\r\n         * @param {string} state    The state type to be updated\r\n         * @param {string} value    The state value to apply to the highlights\r\n         * @returns {undefined}\r\n         */\r\n        this.setAnnotationViewStateForAll = function (state, value) {\r\n            return _highlightsManager.setAnnotationViewStateForAll(state, value);\r\n        };\r\n\r\n        /**\r\n         * Gets a list of the visible midpoint positions of all annotations\r\n         *\r\n         * @returns {HTMLElement[]}\r\n         */\r\n        this.getVisibleAnnotationMidpoints = function () {\r\n            if (reader.getVisibleElements) {\r\n                var $visibleElements = reader.getVisibleElements(_highlightsManager.getAnnotationsElementSelector(), true);\r\n\r\n                var elementMidpoints = _highlightsManager.getAnnotationMidpoints($visibleElements);\r\n                return elementMidpoints || [];\r\n            } else {\r\n                // FIXME: Expose the getVisibleElements call from the reader's internal views.\r\n                console.warn('getAnnotationMidpoints won\\'t work with this version of Readium');\r\n            }\r\n        };\r\n\r\n        reader.on(Globals.Events.CONTENT_DOCUMENT_LOADED, function ($iframe, spineItem) {\r\n            if (_initialized) {\r\n                _highlightsManager.attachAnnotations($iframe, spineItem, reader.getLoadedSpineItems());\r\n            } else {\r\n                _initializedLate = true;\r\n            }\r\n        });\r\n\r\n        ////FIXME: JCCR mj8: this is sometimes faulty, consider removal\r\n        //// automatically redraw annotations.\r\n        //reader.on(ReadiumSDK.Events.PAGINATION_CHANGED, _.debounce(function () {\r\n        //    self.redrawAnnotations();\r\n        //}, 10, true));\r\n\r\n\r\n\r\n    });\r\n\r\n    return config;\r\n});\r\n\ndefine('readium_plugin_highlights', ['readium_plugin_highlights/main'], function (main) { return main; });\n\n"
  ]
}