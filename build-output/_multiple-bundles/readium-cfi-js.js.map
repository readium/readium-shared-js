{
  "version": 3,
  "file": "readium-cfi-js.js",
  "sources": [
    "readium_cfi_js/cfi_parser.js",
    "../../readium-cfi-js/js/cfi_runtime_errors.js",
    "../../readium-cfi-js/js/cfi_instructions.js",
    "../../readium-cfi-js/js/cfi_interpreter.js",
    "../../readium-cfi-js/js/cfi_generator.js",
    "../../readium-cfi-js/js/cfi_API.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACx6CA,ADy6CA;ACx6CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpHA,ADqHA;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtbA,ADubA;ACtbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxfA,ADyfA;ACxfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "EPUBcfiParser = (function() {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { fragment: peg$parsefragment },\n        peg$startRuleFunction  = peg$parsefragment,\n\n        peg$c0 = peg$FAILED,\n        peg$c1 = \"epubcfi(\",\n        peg$c2 = { type: \"literal\", value: \"epubcfi(\", description: \"\\\"epubcfi(\\\"\" },\n        peg$c3 = \")\",\n        peg$c4 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n        peg$c5 = function(fragmentVal) { \n                \n                return { type:\"CFIAST\", cfiString:fragmentVal };\n            },\n        peg$c6 = \",\",\n        peg$c7 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n        peg$c8 = function(stepVal, localPathVal, rangeLocalPath1Val, rangeLocalPath2Val) {\n\n                return { type:\"range\", path:stepVal, localPath:localPathVal, range1:rangeLocalPath1Val, range2:rangeLocalPath2Val };\n          },\n        peg$c9 = function(stepVal, localPathVal) { \n\n                return { type:\"path\", path:stepVal, localPath:localPathVal }; \n            },\n        peg$c10 = [],\n        peg$c11 = null,\n        peg$c12 = function(localPathStepVal, termStepVal) { \n\n                return { steps:localPathStepVal, termStep:termStepVal?termStepVal:\"\" }; \n            },\n        peg$c13 = \"/\",\n        peg$c14 = { type: \"literal\", value: \"/\", description: \"\\\"/\\\"\" },\n        peg$c15 = \"[\",\n        peg$c16 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n        peg$c17 = \"]\",\n        peg$c18 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n        peg$c19 = function(stepLengthVal, assertVal) { \n\n                return { type:\"indexStep\", stepLength:stepLengthVal, idAssertion:assertVal?assertVal[1]:undefined };\n            },\n        peg$c20 = \"!/\",\n        peg$c21 = { type: \"literal\", value: \"!/\", description: \"\\\"!/\\\"\" },\n        peg$c22 = function(stepLengthVal, assertVal) { \n\n                return { type:\"indirectionStep\", stepLength:stepLengthVal, idAssertion:assertVal?assertVal[1]:undefined };\n            },\n        peg$c23 = \":\",\n        peg$c24 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n        peg$c25 = function(textOffsetValue, textLocAssertVal) { \n\n                return { type:\"textTerminus\", offsetValue:textOffsetValue, textAssertion: textLocAssertVal?textLocAssertVal[1]:undefined };\n            },\n        peg$c26 = function(idVal) { \n\n                return idVal; \n            },\n        peg$c27 = function(csvVal, paramVal) { \n\n                return { type:\"textLocationAssertion\", csv:csvVal?csvVal:\"\", parameter:paramVal?paramVal:\"\" }; \n            },\n        peg$c28 = \";\",\n        peg$c29 = { type: \"literal\", value: \";\", description: \"\\\";\\\"\" },\n        peg$c30 = \"=\",\n        peg$c31 = { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\n        peg$c32 = function(paramLHSVal, paramRHSVal) { \n\n                return { type:\"parameter\", LHSValue:paramLHSVal?paramLHSVal:\"\", RHSValue:paramRHSVal?paramRHSVal:\"\" }; \n            },\n        peg$c33 = function(preAssertionVal, postAssertionVal) { \n\n                return { type:\"csv\", preAssertion:preAssertionVal?preAssertionVal:\"\", postAssertion:postAssertionVal?postAssertionVal:\"\" }; \n            },\n        peg$c34 = function(stringVal) { \n\n                return stringVal.join(''); \n            },\n        peg$c35 = function(escSpecCharVal) { \n                \n                return escSpecCharVal[1]; \n            },\n        peg$c36 = /^[1-9]/,\n        peg$c37 = { type: \"class\", value: \"[1-9]\", description: \"[1-9]\" },\n        peg$c38 = /^[0-9]/,\n        peg$c39 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\n        peg$c40 = \".\",\n        peg$c41 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n        peg$c42 = function(intPartVal, fracPartVal) { \n\n                return intPartVal.join('') + \".\" + fracPartVal.join(''); \n            },\n        peg$c43 = \"0\",\n        peg$c44 = { type: \"literal\", value: \"0\", description: \"\\\"0\\\"\" },\n        peg$c45 = function(integerVal) { \n\n                if (integerVal === \"0\") { \n                  return \"0\";\n                } \n                else { \n                  return integerVal[0].concat(integerVal[1].join(''));\n                }\n            },\n        peg$c46 = \" \",\n        peg$c47 = { type: \"literal\", value: \" \", description: \"\\\" \\\"\" },\n        peg$c48 = function() { return \" \"; },\n        peg$c49 = \"^\",\n        peg$c50 = { type: \"literal\", value: \"^\", description: \"\\\"^\\\"\" },\n        peg$c51 = function() { return \"^\"; },\n        peg$c52 = \"\\\"\",\n        peg$c53 = { type: \"literal\", value: \"\\\"\", description: \"\\\"\\\\\\\"\\\"\" },\n        peg$c54 = function() { return '\"'; },\n        peg$c55 = function(bracketVal) { return bracketVal; },\n        peg$c56 = \"(\",\n        peg$c57 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n        peg$c58 = function(paraVal) { return paraVal; },\n        peg$c59 = function() { return \",\"; },\n        peg$c60 = function() { return \";\"; },\n        peg$c61 = function() { return \"=\"; },\n        peg$c62 = /^[a-z]/,\n        peg$c63 = { type: \"class\", value: \"[a-z]\", description: \"[a-z]\" },\n        peg$c64 = /^[A-Z]/,\n        peg$c65 = { type: \"class\", value: \"[A-Z]\", description: \"[A-Z]\" },\n        peg$c66 = \"-\",\n        peg$c67 = { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\n        peg$c68 = \"_\",\n        peg$c69 = { type: \"literal\", value: \"_\", description: \"\\\"_\\\"\" },\n        peg$c70 = function(charVal) { return charVal; },\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$parsefragment() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 8) === peg$c1) {\n        s1 = peg$c1;\n        peg$currPos += 8;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c2); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parserange();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsepath();\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s3 = peg$c3;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c4); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c5(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parserange() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parseindexStep();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselocal_path();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s3 = peg$c6;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c7); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parselocal_path();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c6;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c7); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parselocal_path();\n                if (s6 !== peg$FAILED) {\n                  peg$reportedPos = s0;\n                  s1 = peg$c8(s1, s2, s4, s6);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parsepath() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parseindexStep();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselocal_path();\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c9(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parselocal_path() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseindexStep();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseindirectionStep();\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseindexStep();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseindirectionStep();\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseterminus();\n        if (s2 === peg$FAILED) {\n          s2 = peg$c11;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c12(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseindexStep() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s1 = peg$c13;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c14); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseinteger();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s4 = peg$c15;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidAssertion();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s6 = peg$c17;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c18); }\n              }\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c0;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$c11;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c19(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseindirectionStep() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c20) {\n        s1 = peg$c20;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseinteger();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s4 = peg$c15;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseidAssertion();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s6 = peg$c17;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c18); }\n              }\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c0;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$c11;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c22(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseterminus() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s1 = peg$c23;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c24); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseinteger();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s4 = peg$c15;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsetextLocationAssertion();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s6 = peg$c17;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c18); }\n              }\n              if (s6 !== peg$FAILED) {\n                s4 = [s4, s5, s6];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$c0;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = peg$c11;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c25(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseidAssertion() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      s1 = peg$parsevalue();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c26(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsetextLocationAssertion() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parsecsv();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c11;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseparameter();\n        if (s2 === peg$FAILED) {\n          s2 = peg$c11;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c27(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseparameter() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 59) {\n        s1 = peg$c28;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsevalueNoSpace();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s3 = peg$c30;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c31); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsevalueNoSpace();\n            if (s4 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c32(s2, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parsecsv() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parsevalue();\n      if (s1 === peg$FAILED) {\n        s1 = peg$c11;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s2 = peg$c6;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c7); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsevalue();\n          if (s3 === peg$FAILED) {\n            s3 = peg$c11;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c33(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parsevalueNoSpace() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseescapedSpecialChars();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsecharacter();\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseescapedSpecialChars();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsecharacter();\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c34(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsevalue() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseescapedSpecialChars();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parsecharacter();\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsespace();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parseescapedSpecialChars();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parsecharacter();\n            if (s2 === peg$FAILED) {\n              s2 = peg$parsespace();\n            }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c34(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseescapedSpecialChars() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsecircumflex();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecircumflex();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsecircumflex();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsesquareBracket();\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n        if (s1 === peg$FAILED) {\n          s1 = peg$currPos;\n          s2 = peg$parsecircumflex();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseparentheses();\n            if (s3 !== peg$FAILED) {\n              s2 = [s2, s3];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n          if (s1 === peg$FAILED) {\n            s1 = peg$currPos;\n            s2 = peg$parsecircumflex();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsecomma();\n              if (s3 !== peg$FAILED) {\n                s2 = [s2, s3];\n                s1 = s2;\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n            } else {\n              peg$currPos = s1;\n              s1 = peg$c0;\n            }\n            if (s1 === peg$FAILED) {\n              s1 = peg$currPos;\n              s2 = peg$parsecircumflex();\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parsesemicolon();\n                if (s3 !== peg$FAILED) {\n                  s2 = [s2, s3];\n                  s1 = s2;\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c0;\n                }\n              } else {\n                peg$currPos = s1;\n                s1 = peg$c0;\n              }\n              if (s1 === peg$FAILED) {\n                s1 = peg$currPos;\n                s2 = peg$parsecircumflex();\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parseequal();\n                  if (s3 !== peg$FAILED) {\n                    s2 = [s2, s3];\n                    s1 = s2;\n                  } else {\n                    peg$currPos = s1;\n                    s1 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s1;\n                  s1 = peg$c0;\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c35(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsenumber() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c36.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c37); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        if (peg$c38.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c39); }\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c38.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n            }\n          }\n        } else {\n          s3 = peg$c0;\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c40;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c41); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = [];\n          if (peg$c38.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c39); }\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$c38.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            if (peg$c36.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c37); }\n            }\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$c0;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$c0;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$reportedPos = s0;\n            s1 = peg$c42(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n\n      return s0;\n    }\n\n    function peg$parseinteger() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 48) {\n        s1 = peg$c43;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n      }\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        if (peg$c36.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          if (peg$c38.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c39); }\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c38.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s2 = [s2, s3];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$c0;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$c0;\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c45(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsespace() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 32) {\n        s1 = peg$c46;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c47); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c48();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecircumflex() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 94) {\n        s1 = peg$c49;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c50); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c51();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsedoubleQuote() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c52;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c53); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c54();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsesquareBracket() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c15;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c16); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s1 = peg$c17;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c18); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c55(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseparentheses() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c56;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c57); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s1 = peg$c3;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c4); }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c58(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecomma() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 44) {\n        s1 = peg$c6;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c7); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c59();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsesemicolon() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 59) {\n        s1 = peg$c28;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c60();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseequal() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s1 = peg$c30;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c31); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c61();\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecharacter() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      if (peg$c62.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c63); }\n      }\n      if (s1 === peg$FAILED) {\n        if (peg$c64.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c65); }\n        }\n        if (s1 === peg$FAILED) {\n          if (peg$c38.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c39); }\n          }\n          if (s1 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 45) {\n              s1 = peg$c66;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c67); }\n            }\n            if (s1 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 95) {\n                s1 = peg$c68;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c69); }\n              }\n              if (s1 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 46) {\n                  s1 = peg$c40;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c41); }\n                }\n              }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c70(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n})();\n\ndefine(\"readium_cfi_js/cfi_parser\", (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.EPUBcfiParser;\n    };\n}(this)));\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\n//  \n//  Redistribution and use in source and binary forms, with or without modification, \n//  are permitted provided that the following conditions are met:\n//  1. Redistributions of source code must retain the above copyright notice, this \n//  list of conditions and the following disclaimer.\n//  2. Redistributions in binary form must reproduce the above copyright notice, \n//  this list of conditions and the following disclaimer in the documentation and/or \n//  other materials provided with the distribution.\n//  3. Neither the name of the organization nor the names of its contributors may be \n//  used to endorse or promote products derived from this software without specific \n//  prior written permission.\n\n(function(global) {\n\n\n// Description: This is a set of runtime errors that the CFI interpreter can throw. \n// Rationale: These error types extend the basic javascript error object so error things like the stack trace are \n//   included with the runtime errors. \n\n// REFACTORING CANDIDATE: This type of error may not be required in the long run. The parser should catch any syntax errors, \n//   provided it is error-free, and as such, the AST should never really have any node type errors, which are essentially errors\n//   in the structure of the AST. This error should probably be refactored out when the grammar and interpreter are more stable.\n\nvar obj = {\n\nNodeTypeError: function (node, message) {\n\n    function NodeTypeError () {\n\n        this.node = node;\n    }\n\n    NodeTypeError.prototype = new Error(message);\n    NodeTypeError.constructor = NodeTypeError;\n\n    return new NodeTypeError();\n},\n\n// REFACTORING CANDIDATE: Might make sense to include some more specifics about the out-of-rangeyness.\nOutOfRangeError: function (targetIndex, maxIndex, message) {\n\n    function OutOfRangeError () {\n\n        this.targetIndex = targetIndex;\n        this.maxIndex = maxIndex;\n    }\n\n    OutOfRangeError.prototype = new Error(message);\n    OutOfRangeError.constructor = OutOfRangeError()\n\n    return new OutOfRangeError();\n},\n\n// REFACTORING CANDIDATE: This is a bit too general to be useful. When I have a better understanding of the type of errors\n//   that can occur with the various terminus conditions, it'll make more sense to revisit this. \nTerminusError: function (terminusType, terminusCondition, message) {\n\n    function TerminusError () {\n\n        this.terminusType = terminusType;\n        this.terminusCondition = terminusCondition;\n    }\n\n    TerminusError.prototype = new Error(message);\n    TerminusError.constructor = TerminusError();\n\n    return new TerminusError();\n},\n\nCFIAssertionError: function (expectedAssertion, targetElementAssertion, message) {\n\n    function CFIAssertionError () {\n\n        this.expectedAssertion = expectedAssertion;\n        this.targetElementAssertion = targetElementAssertion;\n    }\n\n    CFIAssertionError.prototype = new Error(message);\n    CFIAssertionError.constructor = CFIAssertionError();\n\n    return new CFIAssertionError();\n}\n\n};\n\n\n\n\n\n\n\n\n\n\nif (typeof define == 'function' && typeof define.amd == 'object') {\n    console.log(\"RequireJS ... cfi_errors\");\n    \n    define('readium_cfi_js/cfi_runtime_errors',[],\n    function () {\n        return obj;\n    });\n} else {\n    console.log(\"!RequireJS ... cfi_errors\");\n    \n    if (!global[\"EPUBcfi\"]) {\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\n    }\n    \n    global.EPUBcfi.NodeTypeError = obj.NodeTypeError;\n    global.EPUBcfi.OutOfRangeError = obj.OutOfRangeError;\n    global.EPUBcfi.TerminusError = obj.TerminusError;\n    global.EPUBcfi.CFIAssertionError = obj.CFIAssertionError;\n}\n\n})(typeof window !== \"undefined\" ? window : this);\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\n//  \n//  Redistribution and use in source and binary forms, with or without modification, \n//  are permitted provided that the following conditions are met:\n//  1. Redistributions of source code must retain the above copyright notice, this \n//  list of conditions and the following disclaimer.\n//  2. Redistributions in binary form must reproduce the above copyright notice, \n//  this list of conditions and the following disclaimer in the documentation and/or \n//  other materials provided with the distribution.\n//  3. Neither the name of the organization nor the names of its contributors may be \n//  used to endorse or promote products derived from this software without specific \n//  prior written permission.\n\n(function(global) {\n\nvar init = function($, cfiRuntimeErrors) {\n    \nvar obj = {\n\n// Description: This model contains the implementation for \"instructions\" included in the EPUB CFI domain specific language (DSL). \n//   Lexing and parsing a CFI produces a set of executable instructions for processing a CFI (represented in the AST). \n//   This object contains a set of functions that implement each of the executable instructions in the AST. \n\n\t// ------------------------------------------------------------------------------------ //\n\t//  \"PUBLIC\" METHODS (THE API)                                                          //\n\t// ------------------------------------------------------------------------------------ //\n\n\t// Description: Follows a step\n\t// Rationale: The use of children() is important here, as this jQuery method returns a tree of xml nodes, EXCLUDING\n\t//   CDATA and text nodes. When we index into the set of child elements, we are assuming that text nodes have been \n\t//   excluded.\n\t// REFACTORING CANDIDATE: This should be called \"followIndexStep\"\n\tgetNextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\n\n\t\t// Find the jquery index for the current node\n\t\tvar $targetNode;\n\t\tif (CFIStepValue % 2 == 0) {\n\n\t\t\t$targetNode = this.elementNodeStep(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);\n\t\t}\n\t\telse {\n\n\t\t\t$targetNode = this.inferTargetTextNode(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);\n\t\t}\n\n\t\treturn $targetNode;\n\t},\n\n\t// Description: This instruction executes an indirection step, where a resource is retrieved using a \n\t//   link contained on a attribute of the target element. The attribute that contains the link differs\n\t//   depending on the target. \n\t// Note: Iframe indirection will (should) fail if the iframe is not from the same domain as its containing script due to \n\t//   the cross origin security policy\n\tfollowIndirectionStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\n\n\t\tvar that = this;\n\t\tvar $contentDocument; \n\t\tvar $blacklistExcluded;\n\t\tvar $startElement;\n\t\tvar $targetNode;\n\n\t\t// TODO: This check must be expanded to all the different types of indirection step\n\t\t// Only expects iframes, at the moment\n\t\tif ($currNode === undefined || !$currNode.is(\"iframe\")) {\n\n\t\t\tthrow cfiRuntimeErrors.NodeTypeError($currNode, \"expected an iframe element\");\n\t\t}\n\n\t\t// Check node type; only iframe indirection is handled, at the moment\n\t\tif ($currNode.is(\"iframe\")) {\n\n\t\t\t// Get content\n\t\t\t$contentDocument = $currNode.contents();\n\n\t\t\t// Go to the first XHTML element, which will be the first child of the top-level document object\n\t\t\t$blacklistExcluded = this.applyBlacklist($contentDocument.children(), classBlacklist, elementBlacklist, idBlacklist);\n\t\t\t$startElement = $($blacklistExcluded[0]);\n\n\t\t\t// Follow an index step\n\t\t\t$targetNode = this.getNextNode(CFIStepValue, $startElement, classBlacklist, elementBlacklist, idBlacklist);\n\n\t\t\t// Return that shit!\n\t\t\treturn $targetNode; \n\t\t}\n\n\t\t// TODO: Other types of indirection\n\t\t// TODO: $targetNode.is(\"embed\")) : src\n\t\t// TODO: ($targetNode.is(\"object\")) : data\n\t\t// TODO: ($targetNode.is(\"image\") || $targetNode.is(\"xlink:href\")) : xlink:href\n\t},\n\n\t// Description: Injects an element at the specified text node\n\t// Arguments: a cfi text termination string, a jquery object to the current node\n\t// REFACTORING CANDIDATE: Rename this to indicate that it injects into a text terminus\n\ttextTermination : function ($currNode, textOffset, elementToInject) {\n\n\t\tvar $injectedElement;\n\t\t// Get the first node, this should be a text node\n\t\tif ($currNode === undefined) {\n\n\t\t\tthrow cfiRuntimeErrors.NodeTypeError($currNode, \"expected a terminating node, or node list\");\n\t\t} \n\t\telse if ($currNode.length === 0) {\n\n\t\t\tthrow cfiRuntimeErrors.TerminusError(\"Text\", \"Text offset:\" + textOffset, \"no nodes found for termination condition\");\n\t\t}\n\n\t\t$injectedElement = this.injectCFIMarkerIntoText($currNode, textOffset, elementToInject);\n\t\treturn $injectedElement;\n\t},\n\n\t// Description: Checks that the id assertion for the node target matches that on \n\t//   the found node. \n\ttargetIdMatchesIdAssertion : function ($foundNode, idAssertion) {\n\n\t\tif ($foundNode.attr(\"id\") === idAssertion) {\n\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\n\t\t\treturn false;\n\t\t}\n\t},\n\n\t// ------------------------------------------------------------------------------------ //\n\t//  \"PRIVATE\" HELPERS                                                                   //\n\t// ------------------------------------------------------------------------------------ //\n\n\t// Description: Step reference for xml element node. Expected that CFIStepValue is an even integer\n\telementNodeStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\n\n\t\tvar $targetNode;\n\t\tvar $blacklistExcluded;\n\t\tvar numElements;\n\t\tvar jqueryTargetNodeIndex = (CFIStepValue / 2) - 1;\n\n\t\t$blacklistExcluded = this.applyBlacklist($currNode.children(), classBlacklist, elementBlacklist, idBlacklist);\n\t\tnumElements = $blacklistExcluded.length;\n\n\t\tif (this.indexOutOfRange(jqueryTargetNodeIndex, numElements)) {\n\n\t\t\tthrow cfiRuntimeErrors.OutOfRangeError(jqueryTargetNodeIndex, numElements - 1, \"\");\n\t\t}\n\n\t    $targetNode = $($blacklistExcluded[jqueryTargetNodeIndex]);\n\t\treturn $targetNode;\n\t},\n\n\tretrieveItemRefHref : function ($itemRefElement, $packageDocument) {\n\n\t\treturn $(\"#\" + $itemRefElement.attr(\"idref\"), $packageDocument).attr(\"href\");\n\t},\n\n\tindexOutOfRange : function (targetIndex, numChildElements) {\n\n\t\treturn (targetIndex > numChildElements - 1) ? true : false;\n\t},\n\n\t// Rationale: In order to inject an element into a specific position, access to the parent object \n\t//   is required. This is obtained with the jquery parent() method. An alternative would be to \n\t//   pass in the parent with a filtered list containing only children that are part of the target text node.\n    injectCFIMarkerIntoText : function ($textNodeList, textOffset, elementToInject) {\n        var document = $textNodeList[0].ownerDocument;\n\n        var nodeNum;\n        var currNodeLength;\n        var currTextPosition = 0;\n        var nodeOffset;\n        var originalText;\n        var $injectedNode;\n        var $newTextNode;\n        // The iteration counter may be incorrect here (should be $textNodeList.length - 1 ??)\n        for (nodeNum = 0; nodeNum <= $textNodeList.length; nodeNum++) {\n\n            if ($textNodeList[nodeNum].nodeType === Node.TEXT_NODE) {\n\n                currNodeMaxIndex = $textNodeList[nodeNum].nodeValue.length  + currTextPosition;\n                nodeOffset = textOffset - currTextPosition;\n\n                if (currNodeMaxIndex > textOffset) {\n\n                    // This node is going to be split and the components re-inserted\n                    originalText = $textNodeList[nodeNum].nodeValue;\t\n\n                    // Before part\n                    $textNodeList[nodeNum].nodeValue = originalText.slice(0, nodeOffset);\n\n                    // Injected element\n                    $injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));\n\n                    // After part\n                    $newTextNode = $(document.createTextNode(originalText.slice(nodeOffset, originalText.length)));\n                    $($newTextNode).insertAfter($injectedNode);\n\n                    return $injectedNode;\n                } else if (currNodeMaxIndex == textOffset){\n                    $injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));\n                    return $injectedNode;\n                }\n                else {\n                    currTextPosition = currNodeMaxIndex;\n                }\n            } else if($textNodeList[nodeNum].nodeType === Node.COMMENT_NODE){\n            \tcurrNodeMaxIndex = $textNodeList[nodeNum].nodeValue.length + 7 + currTextPosition;\n                currTextPosition = currNodeMaxIndex;\n            } else if($textNodeList[nodeNum].nodeType === Node.PROCESSING_INSTRUCTION_NODE){\n            \tcurrNodeMaxIndex = $textNodeList[nodeNum].nodeValue.length + $textNodeList[nodeNum].target.length + 5\n                currTextPosition = currNodeMaxIndex;\n            }\n        }\n\n        throw cfiRuntimeErrors.TerminusError(\"Text\", \"Text offset:\" + textOffset, \"The offset exceeded the length of the text\");\n    },\n\n\t// Rationale: In order to inject an element into a specific position, access to the parent object \n\t//   is required. This is obtained with the jquery parent() method. An alternative would be to \n\t//   pass in the parent with a filtered list containing only children that are part of the target text node.\n\n\t// Description: This method finds a target text node and then injects an element into the appropriate node\n\t// Rationale: The possibility that cfi marker elements have been injected into a text node at some point previous to \n\t//   this method being called (and thus splitting the original text node into two separate text nodes) necessitates that\n\t//   the set of nodes that compromised the original target text node are inferred and returned.\n\t// Notes: Passed a current node. This node should have a set of elements under it. This will include at least one text node, \n\t//   element nodes (maybe), or possibly a mix. \n\t// REFACTORING CANDIDATE: This method is pretty long (and confusing). Worth investigating to see if it can be refactored into something clearer.\n\tinferTargetTextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {\n\t\t\n\t\tvar $elementsWithoutMarkers;\n\t\tvar currLogicalTextNodeIndex;\n\t\tvar targetLogicalTextNodeIndex;\n\t\tvar nodeNum;\n\t\tvar $targetTextNodeList;\n\t\tvar prevNodeWasTextNode;\n\n\t\t// Remove any cfi marker elements from the set of elements. \n\t\t// Rationale: A filtering function is used, as simply using a class selector with jquery appears to \n\t\t//   result in behaviour where text nodes are also filtered out, along with the class element being filtered.\n\t\t$elementsWithoutMarkers = this.applyBlacklist($currNode.contents(), classBlacklist, elementBlacklist, idBlacklist);\n\n\t\t// Convert CFIStepValue to logical index; assumes odd integer for the step value\n\t\ttargetLogicalTextNodeIndex = ((parseInt(CFIStepValue) + 1) / 2) - 1;\n\n\t\t// Set text node position counter\n\t\tcurrLogicalTextNodeIndex = 0;\n\t\tprevNodeWasTextNode = false;\n\t\t$targetTextNodeList = $elementsWithoutMarkers.filter(\n\t\t\tfunction () {\n\n\t\t\t\tif (currLogicalTextNodeIndex === targetLogicalTextNodeIndex) {\n\n\t\t\t\t\t// If it's a text node\n\t\t\t\t\tif (this.nodeType === Node.TEXT_NODE || this.nodeType === Node.COMMENT_NODE || this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\n\t\t\t\t\t\tprevNodeWasTextNode = true;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// Rationale: The logical text node position is only incremented once a group of text nodes (a single logical\n\t\t\t\t\t//   text node) has been passed by the loop. \n\t\t\t\t\telse if (prevNodeWasTextNode && (this.nodeType !== Node.TEXT_NODE)) {\n\t\t\t\t\t\tcurrLogicalTextNodeIndex++;\n\t\t\t\t\t\tprevNodeWasTextNode = false;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Don't return any elements\n\t\t\t\telse {\n\n\t\t\t\t\tif (this.nodeType === Node.TEXT_NODE || this.nodeType === Node.COMMENT_NODE || this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\n\t\t\t\t\t\tprevNodeWasTextNode = true;\n\t\t\t\t\t}else if (!prevNodeWasTextNode && this.nodeType === Node.ELEMENT_NODE){\n                        currLogicalTextNodeIndex++;\n\t\t\t\t\t\tprevNodeWasTextNode = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (prevNodeWasTextNode && (this.nodeType !== Node.TEXT_NODE) && (this !== $elementsWithoutMarkers.lastChild)) {\n\t\t\t\t\t\tcurrLogicalTextNodeIndex++;\n\t\t\t\t\t\tprevNodeWasTextNode = false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// The filtering above should have counted the number of \"logical\" text nodes; this can be used to \n\t\t// detect out of range errors\n\t\tif ($targetTextNodeList.length === 0) {\n\t\t\tthrow cfiRuntimeErrors.OutOfRangeError(targetLogicalTextNodeIndex, currLogicalTextNodeIndex, \"Index out of range\");\n\t\t}\n\n\t\t// return the text node list\n\t\treturn $targetTextNodeList;\n\t},\n\n\tapplyBlacklist : function ($elements, classBlacklist, elementBlacklist, idBlacklist) {\n\n        var $filteredElements;\n\n        $filteredElements = $elements.filter(\n            function () {\n\n                var $currElement = $(this);\n                var includeInList = true;\n\n                if (classBlacklist) {\n\n                \t// Filter each element with the class type\n                \t$.each(classBlacklist, function (index, value) {\n\n\t                    if ($currElement.hasClass(value)) {\n\t                    \tincludeInList = false;\n\n\t                    \t// Break this loop\n\t                        return false;\n\t                    }\n                \t});\n                }\n\n                if (elementBlacklist) {\n                \t\n\t                // For each type of element\n\t                $.each(elementBlacklist, function (index, value) {\n\n\t                    if ($currElement.is(value)) {\n\t                    \tincludeInList = false;\n\n\t                    \t// Break this loop\n\t                        return false;\n\t                    }\n\t                });\n\t\t\t\t}\n\n\t\t\t\tif (idBlacklist) {\n                \t\n\t                // For each type of element\n\t                $.each(idBlacklist, function (index, value) {\n\n\t                    if ($currElement.attr(\"id\") === value) {\n\t                    \tincludeInList = false;\n\n\t                    \t// Break this loop\n\t                        return false;\n\t                    }\n\t                });\n\t\t\t\t}\n\n                return includeInList;\n            }\n        );\n\n        return $filteredElements;\n    }\n};\n\nreturn obj;\n}\n\n\n\n\n\n\n\n\n\n\nif (typeof define == 'function' && typeof define.amd == 'object') {\n    console.log(\"RequireJS ... cfi_instructions\");\n    \n    define('readium_cfi_js/cfi_instructions',['jquery', './cfi_runtime_errors'],\n    function ($, cfiRuntimeErrors) {\n        return init($, cfiRuntimeErrors);\n    });\n} else {\n    console.log(\"!RequireJS ... cfi_instructions\");\n    \n    if (!global[\"EPUBcfi\"]) {\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\n    }\n    global.EPUBcfi.CFIInstructions = \n    init($,\n        {\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\n            TerminusError: global.EPUBcfi.TerminusError,\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\n        });\n}\n\n})(typeof window !== \"undefined\" ? window : this);\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\n//\n//  Redistribution and use in source and binary forms, with or without modification,\n//  are permitted provided that the following conditions are met:\n//  1. Redistributions of source code must retain the above copyright notice, this\n//  list of conditions and the following disclaimer.\n//  2. Redistributions in binary form must reproduce the above copyright notice,\n//  this list of conditions and the following disclaimer in the documentation and/or\n//  other materials provided with the distribution.\n//  3. Neither the name of the organization nor the names of its contributors may be\n//  used to endorse or promote products derived from this software without specific\n//  prior written permission.\n\n(function(global) {\n\nvar init = function($, cfiParser, cfiInstructions, cfiRuntimeErrors) {\n\n    if (typeof cfiParser === \"undefined\") {\n        throw new Error(\"UNDEFINED?! cfiParser\");\n    }\n\n    if (typeof cfiInstructions === \"undefined\") {\n        throw new Error(\"UNDEFINED?! cfiInstructions\");\n    }\n\n    if (typeof cfiRuntimeErrors === \"undefined\") {\n        throw new Error(\"UNDEFINED?! cfiRuntimeErrors\");\n    }\n\nvar obj = {\n\n// Description: This is an interpreter that inteprets an Abstract Syntax Tree (AST) for a CFI. The result of executing the interpreter\n//   is to inject an element, or set of elements, into an EPUB content document (which is just an XHTML document). These element(s) will\n//   represent the position or area in the EPUB referenced by a CFI.\n// Rationale: The AST is a clean and readable expression of the step-terminus structure of a CFI. Although building an interpreter adds to the\n//   CFI infrastructure, it provides a number of benefits. First, it emphasizes a clear separation of concerns between lexing/parsing a\n//   CFI, which involves some complexity related to escaped and special characters, and the execution of the underlying set of steps\n//   represented by the CFI. Second, it will be easier to extend the interpreter to account for new/altered CFI steps (say for references\n//   to vector objects or multiple CFIs) than if lexing, parsing and interpretation were all handled in a single step. Finally, Readium's objective is\n//   to demonstrate implementation of the EPUB 3.0 spec. An implementation with a strong separation of concerns that conforms to\n//   well-understood patterns for DSL processing should be easier to communicate, analyze and understand.\n// REFACTORING CANDIDATE: node type errors shouldn't really be possible if the CFI syntax is correct and the parser is error free.\n//   Might want to make the script die in those instances, once the grammar and interpreter are more stable.\n// REFACTORING CANDIDATE: The use of the 'nodeType' property is confusing as this is a DOM node property and the two are unrelated.\n//   Whoops. There shouldn't be any interference, however, I think this should be changed.\n\n    // ------------------------------------------------------------------------------------ //\n    //  \"PUBLIC\" METHODS (THE API)                                                          //\n    // ------------------------------------------------------------------------------------ //\n\n    // Description: Find the content document referenced by the spine item. This should be the spine item\n    //   referenced by the first indirection step in the CFI.\n    // Rationale: This method is a part of the API so that the reading system can \"interact\" the content document\n    //   pointed to by a CFI. If this is not a separate step, the processing of the CFI must be tightly coupled with\n    //   the reading system, as it stands now.\n    getContentDocHref : function (CFI, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\n\n        var $packageDocument = $(packageDocument);\n        var decodedCFI = decodeURI(CFI);\n        var CFIAST = cfiParser.parse(decodedCFI);\n\n        if (!CFIAST || CFIAST.type !== \"CFIAST\") {\n            throw cfiRuntimeErrors.NodeTypeError(CFIAST, \"expected CFI AST root node\");\n        }\n\n        // Interpet the path node (the package document step)\n        var $packageElement = $($(\"package\", $packageDocument)[0]);\n        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $packageElement, classBlacklist, elementBlacklist, idBlacklist);\n        foundHref = this.searchLocalPathForHref($currElement, $packageDocument, CFIAST.cfiString.localPath, classBlacklist, elementBlacklist, idBlacklist);\n\n        if (foundHref) {\n            return foundHref;\n        }\n        else {\n            return undefined;\n        }\n    },\n\n    // Description: Inject an arbitrary html element into a position in a content document referenced by a CFI\n    injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {\n\n        var decodedCFI = decodeURI(CFI);\n        var CFIAST = cfiParser.parse(decodedCFI);\n        var indirectionNode;\n        var indirectionStepNum;\n        var $currElement;\n\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning\n        //   of the indirection step that referenced the content document.\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\n        indirectionNode.type = \"indexStep\";\n\n        // Interpret the rest of the steps\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\n\n        // TODO: detect what kind of terminus; for now, text node termini are the only kind implemented\n        $currElement = this.interpretTextTerminusNode(CFIAST.cfiString.localPath.termStep, $currElement, elementToInject);\n\n        // Return the element that was injected into\n        return $currElement;\n    },\n\n    // Description: Inject an arbitrary html element into a position in a content document referenced by a CFI\n    injectRangeElements : function (rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist) {\n\n        var decodedCFI = decodeURI(rangeCFI);\n        var CFIAST = cfiParser.parse(decodedCFI);\n        var indirectionNode;\n        var indirectionStepNum;\n        var $currElement;\n        var $range1TargetElement;\n        var $range2TargetElement;\n\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning\n        //   of the indirection step that referenced the content document.\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\n        indirectionNode.type = \"indexStep\";\n\n        // Interpret the rest of the steps in the first local path\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\n\n        // Interpret the first range local_path\n        $range1TargetElement = this.interpretLocalPath(CFIAST.cfiString.range1, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\n        $range1TargetElement = this.interpretTextTerminusNode(CFIAST.cfiString.range1.termStep, $range1TargetElement, startElementToInject);\n\n        // Interpret the second range local_path\n        $range2TargetElement = this.interpretLocalPath(CFIAST.cfiString.range2, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\n        $range2TargetElement = this.interpretTextTerminusNode(CFIAST.cfiString.range2.termStep, $range2TargetElement, endElementToInject);\n\n        // Return the element that was injected into\n        return {\n            startElement : $range1TargetElement[0],\n            endElement : $range2TargetElement[0]\n        };\n    },\n\n    // Description: This method will return the element or node (say, a text node) that is the final target of the\n    //   the CFI.\n    getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\n\n        var decodedCFI = decodeURI(CFI);\n        var CFIAST = cfiParser.parse(decodedCFI);\n        var indirectionNode;\n        var indirectionStepNum;\n        var $currElement;\n\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning\n        //   of the indirection step that referenced the content document.\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\n        indirectionNode.type = \"indexStep\";\n\n        // Interpret the rest of the steps\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\n\n        // Return the element at the end of the CFI\n        return $currElement;\n    },\n\n    // Description: This method will return the start and end elements (along with their char offsets) that are the final targets of the range CFI.\n    getRangeTargetElements : function (rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\n\n        var decodedCFI = decodeURI(rangeCFI);\n        var CFIAST = cfiParser.parse(decodedCFI);\n        var indirectionNode;\n        var indirectionStepNum;\n        var $currElement;\n        var $range1TargetElement;\n        var $range2TargetElement;\n\n        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning\n        //   of the indirection step that referenced the content document.\n        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion\n        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);\n        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];\n        indirectionNode.type = \"indexStep\";\n\n        // Interpret the rest of the steps\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, indirectionStepNum, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\n\n        // Interpret first range local_path\n        $range1TargetElement = this.interpretLocalPath(CFIAST.cfiString.range1, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\n\n        // Interpret second range local_path\n        $range2TargetElement = this.interpretLocalPath(CFIAST.cfiString.range2, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\n\n        // Get the start and end character offsets\n        var startOffset = parseInt(CFIAST.cfiString.range1.termStep.offsetValue) || undefined;\n        var endOffset = parseInt(CFIAST.cfiString.range2.termStep.offsetValue) || undefined;\n\n        // Return the element (and char offsets) at the end of the CFI\n        return {\n            startElement: $range1TargetElement[0],\n            startOffset: startOffset,\n            endElement: $range2TargetElement[0],\n            endOffset: endOffset\n        };\n    },\n\n    // Description: This method allows a \"partial\" CFI to be used to reference a target in a content document, without a\n    //   package document CFI component.\n    // Arguments: {\n    //     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be\n    //        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that\n    //        that has no defined meaning in the spec.)\n    //     contentDocument : A DOM representation of the content document to which the partial CFI refers.\n    // }\n    // Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care\n    getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\n\n        var decodedCFI = decodeURI(contentDocumentCFI);\n        var CFIAST = cfiParser.parse(decodedCFI);\n        var indirectionNode;\n\n        // Interpret the path node\n        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\n\n        // Interpret the rest of the steps\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\n\n        // Return the element at the end of the CFI\n        return $currElement;\n    },\n\n    // Description: This method allows a \"partial\" CFI to be used, with a content document, to return the text node and offset\n    //    referenced by the partial CFI.\n    // Arguments: {\n    //     contentDocumentCFI : This is a partial CFI that represents a path in a content document only. This partial must be\n    //        syntactically valid, even though it references a path starting at the top of a content document (which is a CFI that\n    //        that has no defined meaning in the spec.)\n    //     contentDocument : A DOM representation of the content document to which the partial CFI refers.\n    // }\n    // Rationale: This method exists to meet the requirements of the Readium-SDK and should be used with care\n    getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\n\n        var decodedCFI = decodeURI(contentDocumentCFI);\n        var CFIAST = cfiParser.parse(decodedCFI);\n        var indirectionNode;\n        var textOffset;\n\n        // Interpret the path node\n        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $(\"html\", contentDocument), classBlacklist, elementBlacklist, idBlacklist);\n\n        // Interpret the rest of the steps\n        $currElement = this.interpretLocalPath(CFIAST.cfiString.localPath, 0, $currElement, classBlacklist, elementBlacklist, idBlacklist);\n\n        // Return the element at the end of the CFI\n        textOffset = parseInt(CFIAST.cfiString.localPath.termStep.offsetValue);\n        return { textNode : $currElement,\n                 textOffset : textOffset\n            };\n    },\n    // Description: This function will determine if the input CFI is expressed as a range\n    isRangeCfi: function (cfi) {\n        var CFIAST = cfiParser.parse(cfi);\n        return CFIAST.cfiString.range1 ? true : false;\n    },\n\n    // ------------------------------------------------------------------------------------ //\n    //  \"PRIVATE\" HELPERS                                                                   //\n    // ------------------------------------------------------------------------------------ //\n\n    getFirstIndirectionStepNum : function (CFIAST) {\n\n        // Find the first indirection step in the local path; follow it like a regular step, as the step in the content document it\n        //   references is already loaded and has been passed to this method\n        var stepNum = 0;\n        for (stepNum; stepNum <= CFIAST.cfiString.localPath.steps.length - 1 ; stepNum++) {\n\n            nextStepNode = CFIAST.cfiString.localPath.steps[stepNum];\n            if (nextStepNode.type === \"indirectionStep\") {\n                return stepNum;\n            }\n        }\n    },\n\n    // REFACTORING CANDIDATE: cfiString node and start step num could be merged into one argument, by simply passing the\n    //   starting step... probably a good idea, this would make the meaning of this method clearer.\n    interpretLocalPath : function (localPathNode, startStepNum, $currElement, classBlacklist, elementBlacklist, idBlacklist) {\n\n        var stepNum = startStepNum;\n        var nextStepNode;\n        for (stepNum; stepNum <= localPathNode.steps.length - 1 ; stepNum++) {\n\n            nextStepNode = localPathNode.steps[stepNum];\n            if (nextStepNode.type === \"indexStep\") {\n\n                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\n            }\n            else if (nextStepNode.type === \"indirectionStep\") {\n\n                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\n            }\n        }\n\n        return $currElement;\n    },\n\n    interpretIndexStepNode : function (indexStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {\n\n        // Check node type; throw error if wrong type\n        if (indexStepNode === undefined || indexStepNode.type !== \"indexStep\") {\n\n            throw cfiRuntimeErrors.NodeTypeError(indexStepNode, \"expected index step node\");\n        }\n\n        // Index step\n        var $stepTarget = cfiInstructions.getNextNode(indexStepNode.stepLength, $currElement, classBlacklist, elementBlacklist, idBlacklist);\n\n        // Check the id assertion, if it exists\n        if (indexStepNode.idAssertion) {\n\n            if (!cfiInstructions.targetIdMatchesIdAssertion($stepTarget, indexStepNode.idAssertion)) {\n\n                throw cfiRuntimeErrors.CFIAssertionError(indexStepNode.idAssertion, $stepTarget.attr('id'), \"Id assertion failed\");\n            }\n        }\n\n        return $stepTarget;\n    },\n\n    interpretIndirectionStepNode : function (indirectionStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {\n\n        // Check node type; throw error if wrong type\n        if (indirectionStepNode === undefined || indirectionStepNode.type !== \"indirectionStep\") {\n\n            throw cfiRuntimeErrors.NodeTypeError(indirectionStepNode, \"expected indirection step node\");\n        }\n\n        // Indirection step\n        var $stepTarget = cfiInstructions.followIndirectionStep(\n            indirectionStepNode.stepLength,\n            $currElement,\n            classBlacklist,\n            elementBlacklist);\n\n        // Check the id assertion, if it exists\n        if (indirectionStepNode.idAssertion) {\n\n            if (!cfiInstructions.targetIdMatchesIdAssertion($stepTarget, indirectionStepNode.idAssertion)) {\n\n                throw cfiRuntimeErrors.CFIAssertionError(indirectionStepNode.idAssertion, $stepTarget.attr('id'), \"Id assertion failed\");\n            }\n        }\n\n        return $stepTarget;\n    },\n\n    // REFACTORING CANDIDATE: The logic here assumes that a user will always want to use this terminus\n    //   to inject content into the found node. This will not always be the case, and different types of interpretation\n    //   are probably desired.\n    interpretTextTerminusNode : function (terminusNode, $currElement, elementToInject) {\n\n        if (terminusNode === undefined || terminusNode.type !== \"textTerminus\") {\n\n            throw cfiRuntimeErrors.NodeTypeError(terminusNode, \"expected text terminus node\");\n        }\n\n        var $injectedElement = cfiInstructions.textTermination(\n            $currElement,\n            terminusNode.offsetValue,\n            elementToInject\n            );\n\n        return $injectedElement;\n    },\n\n    searchLocalPathForHref : function ($currElement, $packageDocument, localPathNode, classBlacklist, elementBlacklist, idBlacklist) {\n\n        // Interpret the first local_path node, which is a set of steps and and a terminus condition\n        var stepNum = 0;\n        var nextStepNode;\n        for (stepNum = 0 ; stepNum <= localPathNode.steps.length - 1 ; stepNum++) {\n\n            nextStepNode = localPathNode.steps[stepNum];\n            if (nextStepNode.type === \"indexStep\") {\n\n                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\n            }\n            else if (nextStepNode.type === \"indirectionStep\") {\n\n                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);\n            }\n\n            // Found the content document href referenced by the spine item\n            if ($currElement.is(\"itemref\")) {\n\n                return cfiInstructions.retrieveItemRefHref($currElement, $packageDocument);\n            }\n        }\n\n        return undefined;\n    }\n};\n\nreturn obj;\n}\n\n\n\n\n\n\n\n\n\n\nif (typeof define == 'function' && typeof define.amd == 'object') {\n    console.log(\"RequireJS ... cfi_interpreter\");\n\n    define('readium_cfi_js/cfi_interpreter',['jquery', 'readium_cfi_js/cfi_parser', './cfi_instructions', './cfi_runtime_errors'],\n    function ($, cfiParser, cfiInstructions, cfiRuntimeErrors) {\n        return init($, cfiParser, cfiInstructions, cfiRuntimeErrors);\n    });\n} else {\n    console.log(\"!RequireJS ... cfi_interpreter\");\n\n    if (!global[\"EPUBcfi\"]) {\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\n    }\n    global.EPUBcfi.Interpreter =\n    init($,\n        global.EPUBcfi.Parser,\n        global.EPUBcfi.CFIInstructions,\n        {\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\n            TerminusError: global.EPUBcfi.TerminusError,\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\n        });\n}\n\n})(typeof window !== \"undefined\" ? window : this);\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\n//  \n//  Redistribution and use in source and binary forms, with or without modification, \n//  are permitted provided that the following conditions are met:\n//  1. Redistributions of source code must retain the above copyright notice, this \n//  list of conditions and the following disclaimer.\n//  2. Redistributions in binary form must reproduce the above copyright notice, \n//  this list of conditions and the following disclaimer in the documentation and/or \n//  other materials provided with the distribution.\n//  3. Neither the name of the organization nor the names of its contributors may be \n//  used to endorse or promote products derived from this software without specific \n//  prior written permission.\n\n(function(global) {\n\nvar init = function($, cfiInstructions, cfiRuntimeErrors) {\n    \n    if (typeof cfiInstructions === \"undefined\") {\n        throw new Error(\"UNDEFINED?! cfiInstructions\");\n    }\n    \n    if (typeof cfiRuntimeErrors === \"undefined\") {\n        throw new Error(\"UNDEFINED?! cfiRuntimeErrors\");\n    }\n    \nvar obj = {\n\n    // ------------------------------------------------------------------------------------ //\n    //  \"PUBLIC\" METHODS (THE API)                                                          //\n    // ------------------------------------------------------------------------------------ //\n\n    generateCharOffsetRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\n        var document = rangeStartElement.ownerDocument;\n\n        var docRange;\n        var commonAncestor;\n        var $rangeStartParent;\n        var $rangeEndParent;\n        var range1OffsetStep;\n        var range1CFI;\n        var range2OffsetStep;\n        var range2CFI;\n        var commonCFIComponent;\n\n        this.validateStartTextNode(rangeStartElement);\n        this.validateStartTextNode(rangeEndElement);\n\n        // Parent element is the same\n        if ($(rangeStartElement).parent()[0] === $(rangeEndElement).parent()[0]) {\n            range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);\n            range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);          \n            commonCFIComponent = this.createCFIElementSteps($(rangeStartElement).parent(), \"html\", classBlacklist, elementBlacklist, idBlacklist);\n            return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1OffsetStep + \",\" + range2OffsetStep;\n        }\n        else {\n\n            // Create a document range to find the common ancestor\n            docRange = document.createRange();\n            docRange.setStart(rangeStartElement, startOffset);\n            docRange.setEnd(rangeEndElement, endOffset);\n            commonAncestor = docRange.commonAncestorContainer;\n\n            // Generate terminating offset and range 1\n            range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);\n            $rangeStartParent = $(rangeStartElement).parent();\n            if ($rangeStartParent[0] === commonAncestor) {\n              // rangeStartElement is a text child node of the commonAncestor, so it's CFI sub-path is only the text node step:\n              range1CFI = range1OffsetStep;\n            } else {\n              range1CFI = this.createCFIElementSteps($rangeStartParent, commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range1OffsetStep;\n            }\n\n            // Generate terminating offset and range 2\n            range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);\n            $rangeEndParent = $(rangeEndElement).parent();\n            if ($rangeEndParent[0] === commonAncestor) {\n              // rangeEndElement is a text child node of the commonAncestor, so it's CFI sub-path is only the text node step:\n              range2CFI = range2OffsetStep;\n            } else {\n              range2CFI = this.createCFIElementSteps($rangeEndParent, commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range2OffsetStep;\n            }\n\n            // Generate shared component\n            commonCFIComponent = this.createCFIElementSteps($(commonAncestor), \"html\", classBlacklist, elementBlacklist, idBlacklist);\n\n            // Return the result\n            return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1CFI + \",\" + range2CFI;\n        }\n    },\n\n    generateElementRangeComponent : function (rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist) {\n        var document = rangeStartElement.ownerDocument;\n\n        var docRange;\n        var commonAncestor;\n        var range1CFI;\n        var range2CFI;\n        var commonCFIComponent;\n\n        this.validateStartElement(rangeStartElement);\n        this.validateStartElement(rangeEndElement);\n\n        if (rangeStartElement === rangeEndElement) {\n            throw new Error(\"Start and end element cannot be the same for a CFI range\");\n        }\n\n        // Create a document range to find the common ancestor\n        docRange = document.createRange();\n        docRange.setStart(rangeStartElement, 0);\n        docRange.setEnd(rangeEndElement, rangeEndElement.childNodes.length);\n        commonAncestor = docRange.commonAncestorContainer;\n\n        // Generate range 1\n        range1CFI = this.createCFIElementSteps($(rangeStartElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\n\n        // Generate range 2\n        range2CFI = this.createCFIElementSteps($(rangeEndElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\n\n        // Generate shared component\n        commonCFIComponent = this.createCFIElementSteps($(commonAncestor), \"html\", classBlacklist, elementBlacklist, idBlacklist);\n\n        // Return the result\n        return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1CFI + \",\" + range2CFI;\n    },\n\n    generateRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\n        var document = rangeStartElement.ownerDocument;\n\n        if(rangeStartElement.nodeType === Node.ELEMENT_NODE && rangeEndElement.nodeType === Node.ELEMENT_NODE){\n            return this.generateElementRangeComponent(rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist);\n        } else if(rangeStartElement.nodeType === Node.TEXT_NODE && rangeEndElement.nodeType === Node.TEXT_NODE){\n            return this.generateCharOffsetRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);\n        } else {\n            var docRange;\n            var range1CFI;\n            var range1OffsetStep;\n            var range2CFI;\n            var range2OffsetStep;\n            var commonAncestor;\n            var commonCFIComponent;\n\n            // Create a document range to find the common ancestor\n            docRange = document.createRange();\n            docRange.setStart(rangeStartElement, startOffset);\n            docRange.setEnd(rangeEndElement, endOffset);\n            commonAncestor = docRange.commonAncestorContainer;\n\n            if(rangeStartElement.nodeType === Node.ELEMENT_NODE){\n                this.validateStartElement(rangeStartElement);\n                range1CFI = this.createCFIElementSteps($(rangeStartElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\n            } else {\n                this.validateStartTextNode(rangeStartElement);\n                // Generate terminating offset and range 1\n                range1OffsetStep = this.createCFITextNodeStep($(rangeStartElement), startOffset, classBlacklist, elementBlacklist, idBlacklist);\n                if($(rangeStartElement).parent().is(commonAncestor)){\n                    range1CFI = range1OffsetStep;\n                } else {\n                    range1CFI = this.createCFIElementSteps($(rangeStartElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range1OffsetStep;    \n                }\n            }\n\n            if(rangeEndElement.nodeType === Node.ELEMENT_NODE){\n                this.validateStartElement(rangeEndElement);\n                range2CFI = this.createCFIElementSteps($(rangeEndElement), commonAncestor, classBlacklist, elementBlacklist, idBlacklist);\n            } else {\n                this.validateStartTextNode(rangeEndElement);\n                // Generate terminating offset and range 2\n                range2OffsetStep = this.createCFITextNodeStep($(rangeEndElement), endOffset, classBlacklist, elementBlacklist, idBlacklist);\n                if($(rangeEndElement).parent().is(commonAncestor)){\n                    range2CFI = range2OffsetStep;\n                } else {\n                    range2CFI = this.createCFIElementSteps($(rangeEndElement).parent(), commonAncestor, classBlacklist, elementBlacklist, idBlacklist) + range2OffsetStep;    \n                }                \n            }\n\n            // Generate shared component\n            commonCFIComponent = this.createCFIElementSteps($(commonAncestor), \"html\", classBlacklist, elementBlacklist, idBlacklist);\n\n            // Return the result\n            return commonCFIComponent.substring(1, commonCFIComponent.length) + \",\" + range1CFI + \",\" + range2CFI;\n        }\n    },\n\n    // Description: Generates a character offset CFI \n    // Arguments: The text node that contains the offset referenced by the cfi, the offset value, the name of the \n    //   content document that contains the text node, the package document for this EPUB.\n    generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {\n\n        var textNodeStep;\n        var contentDocCFI;\n        var $itemRefStartNode;\n        var packageDocCFI;\n\n        this.validateStartTextNode(startTextNode, characterOffset);\n\n        // Create the text node step\n        textNodeStep = this.createCFITextNodeStep($(startTextNode), characterOffset, classBlacklist, elementBlacklist, idBlacklist);\n\n        // Call the recursive method to create all the steps up to the head element of the content document (the \"html\" element)\n        contentDocCFI = this.createCFIElementSteps($(startTextNode).parent(), \"html\", classBlacklist, elementBlacklist, idBlacklist) + textNodeStep;\n        return contentDocCFI.substring(1, contentDocCFI.length);\n    },\n\n    generateElementCFIComponent : function (startElement, classBlacklist, elementBlacklist, idBlacklist) {\n\n        var contentDocCFI;\n        var $itemRefStartNode;\n        var packageDocCFI;\n\n        this.validateStartElement(startElement);\n\n        // Call the recursive method to create all the steps up to the head element of the content document (the \"html\" element)\n        contentDocCFI = this.createCFIElementSteps($(startElement), \"html\", classBlacklist, elementBlacklist, idBlacklist);\n\n        // Remove the ! \n        return contentDocCFI.substring(1, contentDocCFI.length);\n    },\n\n    generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\n\n        this.validateContentDocumentName(contentDocumentName);\n        this.validatePackageDocument(packageDocument, contentDocumentName);\n\n        // Get the start node (itemref element) that references the content document\n        $itemRefStartNode = $(\"itemref[idref='\" + contentDocumentName + \"']\", $(packageDocument));\n\n        // Create the steps up to the top element of the package document (the \"package\" element)\n        packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, \"package\", classBlacklist, elementBlacklist, idBlacklist);\n\n        // Append an !; this assumes that a CFI content document CFI component will be appended at some point\n        return packageDocCFIComponent + \"!\";\n    },\n\n    generatePackageDocumentCFIComponentWithSpineIndex : function (spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\n\n        // Get the start node (itemref element) that references the content document\n        $itemRefStartNode = $($(\"spine\", packageDocument).children()[spineIndex]);\n\n        // Create the steps up to the top element of the package document (the \"package\" element)\n        packageDocCFIComponent = this.createCFIElementSteps($itemRefStartNode, \"package\", classBlacklist, elementBlacklist, idBlacklist);\n\n        // Append an !; this assumes that a CFI content document CFI component will be appended at some point\n        return packageDocCFIComponent + \"!\";\n    },\n\n    generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) {\n\n        return \"epubcfi(\" + packageDocumentCFIComponent + contentDocumentCFIComponent + \")\";  \n    },\n\n    // ------------------------------------------------------------------------------------ //\n    //  \"PRIVATE\" HELPERS                                                                   //\n    // ------------------------------------------------------------------------------------ //\n\n    validateStartTextNode : function (startTextNode, characterOffset) {\n        \n        // Check that the text node to start from IS a text node\n        if (!startTextNode) {\n            throw new cfiRuntimeErrors.NodeTypeError(startTextNode, \"Cannot generate a character offset from a starting point that is not a text node\");\n        } else if (startTextNode.nodeType != 3) {\n            throw new cfiRuntimeErrors.NodeTypeError(startTextNode, \"Cannot generate a character offset from a starting point that is not a text node\");\n        }\n\n        // Check that the character offset is within a valid range for the text node supplied\n        if (characterOffset < 0) {\n            throw new cfiRuntimeErrors.OutOfRangeError(characterOffset, 0, \"Character offset cannot be less than 0\");\n        }\n        else if (characterOffset > startTextNode.nodeValue.length) {\n            throw new cfiRuntimeErrors.OutOfRangeError(characterOffset, startTextNode.nodeValue.length - 1, \"character offset cannot be greater than the length of the text node\");\n        }\n    },\n\n    validateStartElement : function (startElement) {\n\n        if (!startElement) {\n            throw new cfiRuntimeErrors.NodeTypeError(startElement, \"CFI target element is undefined\");\n        }\n\n        if (!(startElement.nodeType && startElement.nodeType === 1)) {\n            throw new cfiRuntimeErrors.NodeTypeError(startElement, \"CFI target element is not an HTML element\");\n        }\n    },\n\n    validateContentDocumentName : function (contentDocumentName) {\n\n        // Check that the idref for the content document has been provided\n        if (!contentDocumentName) {\n            throw new Error(\"The idref for the content document, as found in the spine, must be supplied\");\n        }\n    },\n\n    validatePackageDocument : function (packageDocument, contentDocumentName) {\n        \n        // Check that the package document is non-empty and contains an itemref element for the supplied idref\n        if (!packageDocument) {\n            throw new Error(\"A package document must be supplied to generate a CFI\");\n        }\n        else if ($($(\"itemref[idref='\" + contentDocumentName + \"']\", packageDocument)[0]).length === 0) {\n            throw new Error(\"The idref of the content document could not be found in the spine\");\n        }\n    },\n\n    // Description: Creates a CFI terminating step to a text node, with a character offset\n    // REFACTORING CANDIDATE: Some of the parts of this method could be refactored into their own methods\n    createCFITextNodeStep : function ($startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {\n\n        var $parentNode;\n        var $contentsExcludingMarkers;\n        var CFIIndex;\n        var indexOfTextNode;\n        var preAssertion;\n        var preAssertionStartIndex;\n        var textLength;\n        var postAssertion;\n        var postAssertionEndIndex;\n\n        // Find text node position in the set of child elements, ignoring any blacklisted elements \n        $parentNode = $startTextNode.parent();\n        $contentsExcludingMarkers = cfiInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);\n\n        // Find the text node index in the parent list, inferring nodes that were originally a single text node\n        var prevNodeWasTextNode;\n        var indexOfFirstInSequence;\n        var textNodeOnlyIndex = 0;\n        var characterOffsetSinceUnsplit = 0;\n        var finalCharacterOffsetInSequence = 0;\n        $.each($contentsExcludingMarkers, \n            function (index) {\n\n            // If this is a text node, check if it matches and return the current index\n            if (this.nodeType === Node.TEXT_NODE || !prevNodeWasTextNode) {\n\n                if (this.nodeType === Node.TEXT_NODE) {\n                    if (this === $startTextNode[0]) {\n\n                        // Set index as the first in the adjacent sequence of text nodes, or as the index of the current node if this \n                        //   node is a standard one sandwiched between two element nodes. \n                        if (prevNodeWasTextNode) {\n                            indexOfTextNode = indexOfFirstInSequence;\n                            finalCharacterOffsetInSequence = characterOffsetSinceUnsplit;\n                        } else {\n                            indexOfTextNode = textNodeOnlyIndex;\n                        }\n                        \n                        // Break out of .each loop\n                        return false; \n                    }\n\n                    // Save this index as the first in sequence of adjacent text nodes, if it is not already set by this point\n                    prevNodeWasTextNode = true;\n                    characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.length;\n                    if (indexOfFirstInSequence === undefined) {\n                        indexOfFirstInSequence = textNodeOnlyIndex;\n                        textNodeOnlyIndex = textNodeOnlyIndex + 1;\n                    }\n                } else if (this.nodeType === Node.ELEMENT_NODE) {\n                    textNodeOnlyIndex = textNodeOnlyIndex + 1;\n                } else if (this.nodeType === Node.COMMENT_NODE) {\n                    prevNodeWasTextNode = true;\n                    characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.length + 7; // 7 is the size of the html comment tag <!--[comment]-->\n                    if (indexOfFirstInSequence === undefined) {\n                        indexOfFirstInSequence = textNodeOnlyIndex;\n                    }\n                } else if (this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\n                    prevNodeWasTextNode = true;\n                    characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.data.length + this.target.length + 5; // 5 is the size of the instruction processing tag including the required space between the target and the data <?[target] [data]?>\n                    if (indexOfFirstInSequence === undefined) {\n                        indexOfFirstInSequence = textNodeOnlyIndex;\n                    }\n                }\n            }\n            // This node is not a text node\n            else if (this.nodeType === Node.ELEMENT_NODE) {\n                prevNodeWasTextNode = false;\n                indexOfFirstInSequence = undefined;\n                characterOffsetSinceUnsplit  = 0;\n            } else if (this.nodeType === Node.COMMENT_NODE) {\n                characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.length + 7; // <!--[comment]-->\n            } else if (this.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {\n                characterOffsetSinceUnsplit = characterOffsetSinceUnsplit + this.data.length + this.target.length + 5; // <?[target] [data]?>\n            }\n        });\n\n        // Convert the text node index to a CFI odd-integer representation\n        CFIIndex = (indexOfTextNode * 2) + 1;\n\n        // TODO: text assertions are not in the grammar yet, I think, or they're just causing problems. This has\n        //   been temporarily removed. \n\n        // Add pre- and post- text assertions\n        // preAssertionStartIndex = (characterOffset - 3 >= 0) ? characterOffset - 3 : 0;\n        // preAssertion = $startTextNode[0].nodeValue.substring(preAssertionStartIndex, characterOffset);\n\n        // textLength = $startTextNode[0].nodeValue.length;\n        // postAssertionEndIndex = (characterOffset + 3 <= textLength) ? characterOffset + 3 : textLength;\n        // postAssertion = $startTextNode[0].nodeValue.substring(characterOffset, postAssertionEndIndex);\n\n        // Gotta infer the correct character offset, as well\n\n        // Return the constructed CFI text node step\n        return \"/\" + CFIIndex + \":\" + (finalCharacterOffsetInSequence + characterOffset);\n         // + \"[\" + preAssertion + \",\" + postAssertion + \"]\";\n    },\n\n    createCFIElementSteps : function ($currNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) {\n\n        var $blacklistExcluded;\n        var $parentNode;\n        var currNodePosition;\n        var CFIPosition;\n        var idAssertion;\n        var elementStep; \n\n\n\n        // per https://github.com/readium/readium-cfi-js/issues/28\n        // if the currentNode is the same as top level element, we're looking at a text node \n        // that's a direct child of \"topLevelElement\" so we don't need to include it in the element step.\n        if ($currNode[0] === topLevelElement) {\n            return \"\";\n        }\n\n        // Find position of current node in parent list\n        $blacklistExcluded = cfiInstructions.applyBlacklist($currNode.parent().children(), classBlacklist, elementBlacklist, idBlacklist);\n        $.each($blacklistExcluded, \n            function (index, value) {\n\n                if (this === $currNode[0]) {\n\n                    currNodePosition = index;\n\n                    // Break loop\n                    return false;\n                }\n        });\n\n        // Convert position to the CFI even-integer representation\n        CFIPosition = (currNodePosition + 1) * 2;\n\n        // Create CFI step with id assertion, if the element has an id\n        if ($currNode.attr(\"id\")) {\n            elementStep = \"/\" + CFIPosition + \"[\" + $currNode.attr(\"id\") + \"]\";\n        }\n        else {\n            elementStep = \"/\" + CFIPosition;\n        }\n\n        // If a parent is an html element return the (last) step for this content document, otherwise, continue.\n        //   Also need to check if the current node is the top-level element. This can occur if the start node is also the\n        //   top level element.\n        $parentNode = $currNode.parent();\n        if ($parentNode.is(topLevelElement) || $currNode.is(topLevelElement)) {\n            \n            // If the top level node is a type from which an indirection step, add an indirection step character (!)\n            // REFACTORING CANDIDATE: It is possible that this should be changed to: if (topLevelElement = 'package') do\n            //   not return an indirection character. Every other type of top-level element may require an indirection\n            //   step to navigate to, thus requiring that ! is always prepended. \n            if (topLevelElement === 'html') {\n                return \"!\" + elementStep;\n            }\n            else {\n                return elementStep;\n            }\n        }\n        else {\n            return this.createCFIElementSteps($parentNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) + elementStep;\n        }\n    }\n};\n\nreturn obj;\n}\n\n\n\n\n\n\n\nif (typeof define == 'function' && typeof define.amd == 'object') {\n    console.log(\"RequireJS ... cfi_generator\");\n    \n    define('readium_cfi_js/cfi_generator',['jquery', './cfi_instructions', './cfi_runtime_errors'],\n    function ($, cfiInstructions, cfiRuntimeErrors) {\n        return init($, cfiInstructions, cfiRuntimeErrors);\n    });\n} else {\n    console.log(\"!RequireJS ... cfi_generator\");\n    \n    if (!global[\"EPUBcfi\"]) {\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\n    }\n    global.EPUBcfi.Generator = \n    init($,\n        global.EPUBcfi.CFIInstructions,\n        {\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\n            TerminusError: global.EPUBcfi.TerminusError,\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\n        });\n}\n\n})(typeof window !== \"undefined\" ? window : this);\n\n",
    "//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\n//\n//  Redistribution and use in source and binary forms, with or without modification,\n//  are permitted provided that the following conditions are met:\n//  1. Redistributions of source code must retain the above copyright notice, this\n//  list of conditions and the following disclaimer.\n//  2. Redistributions in binary form must reproduce the above copyright notice,\n//  this list of conditions and the following disclaimer in the documentation and/or\n//  other materials provided with the distribution.\n//  3. Neither the name of the organization nor the names of its contributors may be\n//  used to endorse or promote products derived from this software without specific\n//  prior written permission.\n\n(function(global) {\n\nvar init = function(cfiParser, cfiInterpreter, cfiInstructions, cfiRuntimeErrors, cfiGenerator) {\n\n    if (typeof cfiParser === \"undefined\") {\n        throw new Error(\"UNDEFINED?! cfiParser\");\n    }\n\n    if (typeof cfiInterpreter === \"undefined\") {\n        throw new Error(\"UNDEFINED?! cfiInterpreter\");\n    }\n\n    if (typeof cfiInstructions === \"undefined\") {\n        throw new Error(\"UNDEFINED?! cfiInstructions\");\n    }\n\n    if (typeof cfiRuntimeErrors === \"undefined\") {\n        throw new Error(\"UNDEFINED?! cfiRuntimeErrors\");\n    }\n\n    if (typeof cfiGenerator === \"undefined\") {\n        throw new Error(\"UNDEFINED?! cfiGenerator\");\n    }\n\n    var obj = {\n\n        getContentDocHref : function (CFI, packageDocument) {\n            return cfiInterpreter.getContentDocHref(CFI, packageDocument);\n        },\n        injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {\n            return cfiInterpreter.injectElement(CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist);\n        },\n        getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\n            return cfiInterpreter.getTargetElement(CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\n        },\n        getTargetElementWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\n            return cfiInterpreter.getTargetElementWithPartialCFI(contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\n        },\n        injectRangeElements : function (rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist) {\n            return cfiInterpreter.injectRangeElements(rangeCFI, contentDocument, startElementToInject, endElementToInject, classBlacklist, elementBlacklist, idBlacklist);\n        },\n        getRangeTargetElements : function (rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\n            return cfiInterpreter.getRangeTargetElements(rangeCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\n        },\n        isRangeCfi : function (cfi) {\n          return cfiInterpreter.isRangeCfi(cfi);\n        },\n        getTextTerminusInfoWithPartialCFI : function (contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {\n            return cfiInterpreter.getTextTerminusInfoWithPartialCFI(contentDocumentCFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist);\n        },\n        generateCharacterOffsetCFIComponent : function (startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {\n            return cfiGenerator.generateCharacterOffsetCFIComponent(startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist);\n        },\n        generateElementCFIComponent : function (startElement, classBlacklist, elementBlacklist, idBlacklist) {\n            return cfiGenerator.generateElementCFIComponent(startElement, classBlacklist, elementBlacklist, idBlacklist);\n        },\n        generatePackageDocumentCFIComponent : function (contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\n            return cfiGenerator.generatePackageDocumentCFIComponent(contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist);\n        },\n        generatePackageDocumentCFIComponentWithSpineIndex : function (spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {\n            return cfiGenerator.generatePackageDocumentCFIComponentWithSpineIndex(spineIndex, packageDocument, classBlacklist, elementBlacklist, idBlacklist);\n        },\n        generateCompleteCFI : function (packageDocumentCFIComponent, contentDocumentCFIComponent) {\n            return cfiGenerator.generateCompleteCFI(packageDocumentCFIComponent, contentDocumentCFIComponent);\n        },\n        generateCharOffsetRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\n            return cfiGenerator.generateCharOffsetRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);\n        },\n        generateElementRangeComponent : function (rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist) {\n            return cfiGenerator.generateElementRangeComponent(rangeStartElement, rangeEndElement, classBlacklist, elementBlacklist, idBlacklist);\n        },\n        generateRangeComponent : function (rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist) {\n            return cfiGenerator.generateRangeComponent(rangeStartElement, startOffset, rangeEndElement, endOffset, classBlacklist, elementBlacklist, idBlacklist);\n        },\n        injectElementAtOffset : function ($textNodeList, textOffset, elementToInject) {\n            return cfiInstructions.injectCFIMarkerIntoText($textNodeList, textOffset, elementToInject);\n        }\n    };\n\n\n    // TODO: remove global (should not be necessary in properly-configured RequireJS build!)\n    // ...but we leave it here as a \"legacy\" mechanism to access the CFI lib functionality\n    // -----\n    obj.CFIInstructions = cfiInstructions;\n    obj.Parser = cfiParser;\n    obj.Interpreter = cfiInterpreter;\n    obj.Generator = cfiGenerator;\n\n    obj.NodeTypeError= cfiRuntimeErrors.NodeTypeError;\n    obj.OutOfRangeError = cfiRuntimeErrors.OutOfRangeError;\n    obj.TerminusError = cfiRuntimeErrors.TerminusError;\n    obj.CFIAssertionError = cfiRuntimeErrors.CFIAssertionError;\n\n    global.EPUBcfi = obj;\n    // -----\n\n    console.log(\"#######################################\");\n    // console.log(global.EPUBcfi);\n    // console.log(\"#######################################\");\n\n    return obj;\n}\n\n\n\n\n\n\nif (typeof define == 'function' && typeof define.amd == 'object') {\n    console.log(\"RequireJS ... cfi_API\");\n\n    define('readium_cfi_js/cfi_API',['readium_cfi_js/cfi_parser', './cfi_interpreter', './cfi_instructions', './cfi_runtime_errors', './cfi_generator'],\n    function (cfiParser, cfiInterpreter, cfiInstructions, cfiRuntimeErrors, cfiGenerator) {\n\n        return init(cfiParser, cfiInterpreter, cfiInstructions, cfiRuntimeErrors, cfiGenerator);\n    });\n} else {\n    console.log(\"!RequireJS ... cfi_API\");\n\n    if (!global[\"EPUBcfi\"]) {\n        throw new Error(\"EPUBcfi not initialised on global object?! (window or this context)\");\n    }\n\n    init(global.EPUBcfi.Parser,\n        global.EPUBcfi.Interpreter,\n        global.EPUBcfi.CFIInstructions,\n        {\n            NodeTypeError: global.EPUBcfi.NodeTypeError,\n            OutOfRangeError: global.EPUBcfi.OutOfRangeError,\n            TerminusError: global.EPUBcfi.TerminusError,\n            CFIAssertionError: global.EPUBcfi.CFIAssertionError\n        },\n        global.EPUBcfi.Generator);\n}\n\n})(typeof window !== \"undefined\" ? window : this);\n\ndefine('readium_cfi_js', ['readium_cfi_js/cfi_API'], function (main) { return main; });\n\n"
  ]
}