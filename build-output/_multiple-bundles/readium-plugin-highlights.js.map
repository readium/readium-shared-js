{
  "version": 3,
  "sources": [
    "../../plugins/highlights/lib/class.js",
    "../../plugins/highlights/helpers.js",
    "../../plugins/highlights/models/text_line_inferrer.js",
    "../../plugins/highlights/lib/length.js",
    "../../plugins/highlights/models/copied_text_styles.js",
    "../../plugins/highlights/views/view.js",
    "../../plugins/highlights/views/border_view.js",
    "../../plugins/highlights/models/group.js",
    "../../plugins/highlights/controller.js",
    "../../plugins/highlights/manager.js",
    "../../plugins/highlights/main.js",
    "../../../../../../../../module-create.js",
    "../../../../../../../../module-insertRequire.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtPA;AACA;AACA,ACFA;AACA;AACA",
  "file": "readium-plugin-highlights.js",
  "sourcesContent": [
    "/* Simple JavaScript Inheritance\n * By John Resig http://ejohn.org/\n * MIT Licensed.\n */\n// Inspired by base2 and Prototype\ndefine('readium_plugin_highlights/lib/class',[],function() {\n\n    var initializing = false,\n        fnTest = /xyz/.test(function() {\n            xyz;\n        }) ? /\\b_super\\b/ : /.*/;\n\n    // The base Class implementation (does nothing)\n    var Class = function() {};\n\n    // Create a new Class that inherits from this class\n    Class.extend = function(prop) {\n        var _super = this.prototype;\n\n        // Instantiate a base class (but only create the instance,\n        // don't run the init constructor)\n        initializing = true;\n        var prototype = new this();\n        initializing = false;\n\n        // Copy the properties over onto the new prototype\n        for (var name in prop) {\n            // Check if we're overwriting an existing function\n            prototype[name] = typeof prop[name] == \"function\" &&\n                typeof _super[name] == \"function\" && fnTest.test(prop[name]) ?\n                (function(name, fn) {\n                    return function() {\n                        var tmp = this._super;\n\n                        // Add a new ._super() method that is the same method\n                        // but on the super-class\n                        this._super = _super[name];\n\n                        // The method only need to be bound temporarily, so we\n                        // remove it when we're done executing\n                        var ret = fn.apply(this, arguments);\n                        this._super = tmp;\n\n                        return ret;\n                    };\n                })(name, prop[name]) :\n                prop[name];\n        }\n\n        // The dummy class constructor\n        function Class() {\n            // All construction is actually done in the init method\n            if (!initializing && this.init)\n                this.init.apply(this, arguments);\n        }\n\n        // Populate our constructed prototype object\n        Class.prototype = prototype;\n\n        // Enforce the constructor to be what we expect\n        Class.prototype.constructor = Class;\n\n        // And make this class extendable\n        Class.extend = arguments.callee;\n\n        return Class;\n    };\n\n    return Class;\n});\n\n",
    "define('readium_plugin_highlights/helpers',[],function() {\n    var HighlightHelpers = {\n        getMatrix: function($obj) {\n            var matrix = $obj.css(\"-webkit-transform\") ||\n                $obj.css(\"-moz-transform\") ||\n                $obj.css(\"-ms-transform\") ||\n                $obj.css(\"-o-transform\") ||\n                $obj.css(\"transform\");\n            return matrix === \"none\" ? undefined : matrix;\n        },\n        getScaleFromMatrix: function(matrix) {\n            var matrixRegex = /matrix\\((-?\\d*\\.?\\d+),\\s*0,\\s*0,\\s*(-?\\d*\\.?\\d+),\\s*0,\\s*0\\)/,\n                matches = matrix.match(matrixRegex);\n            return matches[1];\n        }\n    };\n\n    return HighlightHelpers;\n});\n\n",
    "define('readium_plugin_highlights/models/text_line_inferrer',[\"../lib/class\"], function(Class) {\n    var TextLineInferrer = Class.extend({\n\n        init: function(options) {\n            this.lineHorizontalThreshold = options.lineHorizontalThreshold || 0;\n            this.lineHorizontalLimit = options.lineHorizontalLimit || 0;\n        },\n\n        // ----------------- PUBLIC INTERFACE --------------------------------------------------------------\n\n        inferLines: function(rectTextList) {\n            var inferredLines = [];\n            var numRects = rectTextList.length;\n            var numLines = 0;\n            var currLine;\n            var currRect;\n            var currRectTextObj;\n            var rectAppended;\n\n            // Iterate through each rect\n            for (var currRectNum = 0; currRectNum <= numRects - 1; currRectNum++) {\n                currRectTextObj = rectTextList[currRectNum];\n                currRect = currRectTextObj.rect;\n                // Check if the rect can be added to any of the current lines\n                rectAppended = false;\n\n                if (inferredLines.length > 0) {\n                    currLine = inferredLines[inferredLines.length - 1];\n\n                    if (this.includeRectInLine(currLine.line, currRect.top, currRect.left,\n                            currRect.width, currRect.height)) {\n                        rectAppended = this.expandLine(currLine.line, currRect.left, currRect.top,\n                            currRect.width, currRect.height);\n\n                        currLine.data.push(currRectTextObj);\n                    }\n                }\n\n                if (!rectAppended) {\n                    inferredLines.push({\n                        data: [currRectTextObj],\n                        line: this.createNewLine(currRect.left, currRect.top,\n                            currRect.width, currRect.height)\n                    });\n                    // Update the number of lines, so we're not using .length on every iteration\n                    numLines = numLines + 1;\n                }\n            }\n            return inferredLines;\n        },\n\n\n        // ----------------- PRIVATE HELPERS ---------------------------------------------------------------\n\n        includeRectInLine: function(currLine, rectTop, rectLeft, rectWidth, rectHeight) {\n            // is on an existing line : based on vertical position\n            if (this.rectIsWithinLineVertically(rectTop, rectHeight, currLine.maxTop, currLine.maxBottom)) {\n                if (this.rectIsWithinLineHorizontally(rectLeft, rectWidth, currLine.left,\n                        currLine.width, currLine.avgHeight)) {\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        rectIsWithinLineVertically: function(rectTop, rectHeight, currLineMaxTop, currLineMaxBottom) {\n            var rectBottom = rectTop + rectHeight;\n            var lineHeight = currLineMaxBottom - currLineMaxTop;\n            var lineHeightAdjustment = (lineHeight * 0.75) / 2;\n            var rectHeightAdjustment = (rectHeight * 0.75) / 2;\n\n            rectTop = rectTop + rectHeightAdjustment;\n            rectBottom = rectBottom - rectHeightAdjustment;\n            currLineMaxTop = currLineMaxTop + lineHeightAdjustment;\n            currLineMaxBottom = currLineMaxBottom - lineHeightAdjustment;\n\n            if (rectTop === currLineMaxTop && rectBottom === currLineMaxBottom) {\n                return true;\n            } else if (rectTop < currLineMaxTop && rectBottom < currLineMaxBottom &&\n                rectBottom > currLineMaxTop) {\n                return true;\n            } else if (rectTop > currLineMaxTop && rectBottom > currLineMaxBottom &&\n                rectTop < currLineMaxBottom) {\n                return true;\n            } else if (rectTop > currLineMaxTop && rectBottom < currLineMaxBottom) {\n                return true;\n            } else if (rectTop < currLineMaxTop && rectBottom > currLineMaxBottom) {\n                return true;\n            } else {\n                return false;\n            }\n        },\n\n        rectIsWithinLineHorizontally: function(rectLeft, rectWidth, currLineLeft, currLineWidth,\n            currLineAvgHeight) {\n            var lineGapHeuristic = 2 * currLineAvgHeight;\n            var rectRight = rectLeft + rectWidth;\n            var currLineRight = rectLeft + currLineWidth;\n\n            if ((currLineLeft - rectRight) > lineGapHeuristic) {\n                return false;\n            } else if ((rectLeft - currLineRight) > lineGapHeuristic) {\n                return false;\n            } else {\n                return true;\n            }\n        },\n\n        createNewLine: function(rectLeft, rectTop, rectWidth, rectHeight) {\n            var maxBottom = rectTop + rectHeight;\n\n            return {\n                left: rectLeft,\n                startTop: rectTop,\n                width: rectWidth,\n                avgHeight: rectHeight,\n                maxTop: rectTop,\n                maxBottom: maxBottom,\n                numRects: 1\n            };\n        },\n\n        expandLine: function(currLine, rectLeft, rectTop, rectWidth, rectHeight) {\n            var lineOldRight = currLine.left + currLine.width;\n\n            // Update all the properties of the current line with rect dimensions\n            var rectRight = rectLeft + rectWidth;\n            var rectBottom = rectTop + rectHeight;\n            var numRectsPlusOne = currLine.numRects + 1;\n\n            // Average height calculation\n            var currSumHeights = currLine.avgHeight * currLine.numRects;\n            var avgHeight = Math.ceil((currSumHeights + rectHeight) / numRectsPlusOne);\n            currLine.avgHeight = avgHeight;\n            currLine.numRects = numRectsPlusOne;\n\n            // Expand the line vertically\n            currLine = this.expandLineVertically(currLine, rectTop, rectBottom);\n            currLine = this.expandLineHorizontally(currLine, rectLeft, rectRight);\n\n            return currLine;\n        },\n\n        expandLineVertically: function(currLine, rectTop, rectBottom) {\n            if (rectTop < currLine.maxTop) {\n                currLine.maxTop = rectTop;\n            }\n            if (rectBottom > currLine.maxBottom) {\n                currLine.maxBottom = rectBottom;\n            }\n\n            return currLine;\n        },\n\n        expandLineHorizontally: function(currLine, rectLeft, rectRight) {\n            var newLineLeft = currLine.left <= rectLeft ? currLine.left : rectLeft;\n            var lineRight = currLine.left + currLine.width;\n            var newLineRight = lineRight >= rectRight ? lineRight : rectRight;\n            var newLineWidth = newLineRight - newLineLeft;\n\n            //cancel the expansion if the line is going to expand outside a horizontal limit\n            //this is used to prevent lines from spanning multiple columns in a two column epub view\n            var horizontalThreshold = this.lineHorizontalThreshold;\n            var horizontalLimit = this.lineHorizontalLimit;\n\n            var leftBoundary = Math.floor(newLineLeft / horizontalLimit) * horizontalLimit;\n            var centerBoundary = leftBoundary + horizontalThreshold;\n            var rightBoundary = leftBoundary + horizontalLimit;\n            if ((newLineLeft > leftBoundary && newLineRight > centerBoundary && newLineLeft < centerBoundary) || (newLineLeft > centerBoundary && newLineRight > rightBoundary)) {\n                return undefined;\n            }\n\n            currLine.left = newLineLeft;\n            currLine.width = newLineWidth;\n\n            return currLine;\n        }\n    });\n\n    return TextLineInferrer;\n});\n\n",
    "// https://github.com/heygrady/Units\n//\n// Copyright (c) 2013 Grady Kuhnline\n//\n// MIT License\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\ndefine('readium_plugin_highlights/lib/length',[],function() {\n    return function(document) {\n        \"use strict\";\n\n        // create a test element\n        var testElem = document.createElement('test'),\n            docElement = document.documentElement,\n            defaultView = document.defaultView,\n            getComputedStyle = defaultView && defaultView.getComputedStyle,\n            computedValueBug,\n            runit = /^(-?[\\d+\\.\\-]+)([a-z]+|%)$/i,\n            convert = {},\n            conversions = [1 / 25.4, 1 / 2.54, 1 / 72, 1 / 6],\n            units = ['mm', 'cm', 'pt', 'pc', 'in', 'mozmm'],\n            i = 6; // units.length\n\n        // add the test element to the dom\n        docElement.appendChild(testElem);\n\n        // test for the WebKit getComputedStyle bug\n        // @see http://bugs.jquery.com/ticket/10639\n        if (getComputedStyle) {\n            // add a percentage margin and measure it\n            testElem.style.marginTop = '1%';\n            computedValueBug = getComputedStyle(testElem).marginTop === '1%';\n        }\n\n        // pre-calculate absolute unit conversions\n        while (i--) {\n            convert[units[i] + \"toPx\"] = conversions[i] ? conversions[i] * convert.inToPx : toPx(testElem, '1' + units[i]);\n        }\n\n        // remove the test element from the DOM and delete it\n        docElement.removeChild(testElem);\n        testElem = undefined;\n\n        // convert a value to pixels\n        function toPx(elem, value, prop, force) {\n            // use width as the default property, or specify your own\n            prop = prop || 'width';\n\n            var style,\n                inlineValue,\n                ret,\n                unit = (value.match(runit) || [])[2],\n                conversion = unit === 'px' ? 1 : convert[unit + 'toPx'],\n                rem = /r?em/i;\n\n            if (conversion || rem.test(unit) && !force) {\n                // calculate known conversions immediately\n                // find the correct element for absolute units or rem or fontSize + em or em\n                elem = conversion ? elem : unit === 'rem' ? docElement : prop === 'fontSize' ? elem.parentNode || elem : elem;\n\n                // use the pre-calculated conversion or fontSize of the element for rem and em\n                conversion = conversion || parseFloat(curCSS(elem, 'fontSize'));\n\n                // multiply the value by the conversion\n                ret = parseFloat(value) // conversion;\n            } else {\n                // begin \"the awesome hack by Dean Edwards\"\n                // @see http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n                // remember the current style\n                style = elem.style;\n                inlineValue = style[prop];\n\n                // set the style on the target element\n                try {\n                    style[prop] = value;\n                } catch (e) {\n                    // IE 8 and below throw an exception when setting unsupported units\n                    return 0;\n                }\n\n                // read the computed value\n                // if style is nothing we probably set an unsupported unit\n                ret = !style[prop] ? 0 : parseFloat(curCSS(elem, prop));\n\n                // reset the style back to what it was or blank it out\n                style[prop] = inlineValue !== undefined ? inlineValue : null;\n            }\n\n            // return a number\n            return ret;\n        }\n\n        // return the computed value of a CSS property\n        function curCSS(elem, prop) {\n            var value,\n                pixel,\n                unit,\n                rvpos = /^top|bottom/,\n                outerProp = [\"paddingTop\", \"paddingBottom\", \"borderTop\", \"borderBottom\"],\n                innerHeight,\n                parent,\n                i = 4; // outerProp.length\n\n            if (getComputedStyle) {\n                // FireFox, Chrome/Safari, Opera and IE9+\n                value = getComputedStyle(elem)[prop];\n            } else if (pixel = elem.style['pixel' + prop.charAt(0).toUpperCase() + prop.slice(1)]) {\n                // IE and Opera support pixel shortcuts for top, bottom, left, right, height, width\n                // WebKit supports pixel shortcuts only when an absolute unit is used\n                value = pixel + 'px';\n            } else if (prop === 'fontSize') {\n                // correct IE issues with font-size\n                // @see http://bugs.jquery.com/ticket/760\n                value = toPx(elem, '1em', 'left', 1) + 'px';\n            } else {\n                // IE 8 and below return the specified style\n                value = elem.currentStyle[prop];\n            }\n\n            // check the unit\n            unit = (value.match(runit) || [])[2];\n            if (unit === '%' && computedValueBug) {\n                // WebKit won't convert percentages for top, bottom, left, right, margin and text-indent\n                if (rvpos.test(prop)) {\n                    // Top and bottom require measuring the innerHeight of the parent.\n                    innerHeight = (parent = elem.parentNode || elem).offsetHeight;\n                    while (i--) {\n                        innerHeight -= parseFloat(curCSS(parent, outerProp[i]));\n                    }\n                    value = parseFloat(value) / 100 // innerHeight + 'px';\n                } else {\n                    // This fixes margin, left, right and text-indent\n                    // @see https://bugs.webkit.org/show_bug.cgi?id=29084\n                    // @see http://bugs.jquery.com/ticket/10639\n                    value = toPx(elem, value);\n                }\n            } else if ((value === 'auto' || (unit && unit !== 'px')) && getComputedStyle) {\n                // WebKit and Opera will return auto in some cases\n                // Firefox will pass back an unaltered value when it can't be set, like top on a static element\n                value = 0;\n            } else if (unit && unit !== 'px' && !getComputedStyle) {\n                // IE 8 and below won't convert units for us\n                // try to convert using a prop that will return pixels\n                // this will be accurate for everything (except font-size and some percentages)\n                value = toPx(elem, value) + 'px';\n            }\n            return value;\n        }\n\n        // export the conversion function\n        return {\n            toPx: toPx\n        };\n    };\n});\n\n",
    "define('readium_plugin_highlights/models/copied_text_styles',[],function() {\n    return [\n        \"color\",\n        \"font-family\",\n        \"font-size\",\n        \"font-weight\",\n        \"font-style\",\n        //\"line-height\",\n        \"text-decoration\",\n        \"text-transform\",\n        \"text-shadow\",\n        \"letter-spacing\",\n\n        \"text-rendering\",\n        \"font-kerning\",\n        \"font-language-override\",\n        \"font-size-adjust\",\n        \"font-stretch\",\n        \"font-synthesis\",\n        \"font-variant\",\n        \"font-variant-alternates\",\n        \"font-variant-caps\",\n        \"font-variant-east-asian\",\n        \"font-variant-ligatures\",\n        \"font-variant-numeric\",\n        \"font-variant-position\",\n        \"-webkit-font-smoothing \",\n\n        \"-ms-writing-mode\",\n        \"-webkit-writing-mode\",\n        \"-moz-writing-mode\",\n        \"-ms-writing-mode\",\n        \"writing-mode\",\n\n        \"-webkit-text-orientation\",\n        \"-moz-text-orientation\",\n        \"-ms-text-orientation\",\n        \"text-orientation: mixed\"\n    ];\n});\n\n",
    "define('readium_plugin_highlights/views/view',[\"jquery\", \"underscore\", \"../lib/class\", \"../lib/length\", \"../models/text_line_inferrer\", \"../models/copied_text_styles\"],\nfunction($, _, Class, Length, TextLineInferrer, CopiedTextStyles) {\n    // This is not a backbone view.\n\n    var HighlightView = Class.extend({\n        // this is an element that highlight will be associated with, it is not styled at this point\n        template: \"<div class=\\\"rd-highlight\\\"></div>\",\n\n        init: function(context, options) {\n            this.context = context;\n\n            this.lengthLib = new Length(this.context.document);\n\n            this.highlight = {\n                id: options.id,\n                CFI: options.CFI,\n                type: options.type,\n                top: options.top,\n                left: options.left,\n                height: options.height,\n                width: options.width,\n                styles: options.styles,\n                contentRenderData: options.contentRenderData\n            };\n\n            this.swipeThreshold = 10;\n            this.swipeVelocity = 0.65; // in px/ms\n        },\n\n        render: function() {\n            this.$el = $(this.template, this.context.document);\n            this.$el.attr('data-id', this.highlight.id);\n            this.updateStyles();\n            this.renderContent();\n            return this.$el;\n        },\n\n        remove: function() {\n            this.highlight = null;\n            this.context = null;\n            this.$el.remove();\n        },\n\n\n\n        resetPosition: function(top, left, height, width) {\n            _.assign(this.highlight, {\n                top: top,\n                left: left,\n                height: height,\n                width: width\n            });\n            this.setCSS();\n        },\n\n        setStyles: function(styles) {\n            this.highlight.styles = styles;\n            this.updateStyles();\n        },\n\n        update: function(type, styles) {\n            // save old type\n            var oldType = this.highlight.type;\n\n            _.assign(this.highlight, {\n                type: type,\n                styles: styles\n            });\n\n            // we need to fully restyle view elements\n            // remove all the \"inline\" styles\n            this.$el.removeAttr(\"style\");\n\n            // remove class applied by \"type\"\n            this.$el.removeClass(oldType);\n\n            this.updateStyles();\n        },\n\n        updateStyles: function() {\n            this.setBaseHighlight();\n            this.setCSS();\n        },\n\n        // Will return null or false if :first-line/letter would not apply to the first text node child\n        getFirstTextNodeChild: function(elem) {\n            for (var i = 0; i < elem.childNodes.length; i++) {\n                var child = elem.childNodes[i];\n                if (child.nodeType === Node.TEXT_NODE) {\n                    return child;\n                }\n\n                if (child.nodeType === Node.ELEMENT_NODE) {\n                    var doc = child.ownerDocument;\n                    var style = doc.defaultView.getComputedStyle(child);\n                    // If it's not an element we can definitely ignore\n                    if ((style['position'] !== 'absolute' && style['position'] !== 'fixed') &&\n                        style['float'] === 'none' && style['display'] !== 'none') {\n                        if (style['display'] === 'inline') {\n                            var result = this.getFirstTextNodeChild(child);\n                            if (result) {\n                                return result;\n                            } else if (result === false) {\n                                return false;\n                            }\n                        } else {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return null;\n        },\n\n        // Returns the styles which apply to the first line of the specified element, or null if there aren't any\n        // Assumes that the specified argument is a block element\n        getFirstLineStyles: function(elem) {\n            var win = elem.ownerDocument.defaultView;\n            if (!win.getMatchedCSSRules) {\n                // Without getMatchingCSSRules, we can't get first-line styles\n                return null;\n            }\n            while (elem) {\n                var styles = win.getMatchedCSSRules(elem, 'first-line');\n                if (styles) {\n                    return styles[0].style;\n                }\n\n                // Go through previous siblings, return null if there's a non-empty text node, or an element that's\n                // not display: none; - both of these prevent :first-line styles from the parents from applying\n                var sibling = elem;\n                while (sibling = sibling.previousSibling) {\n                    if (sibling.nodeType === Node.ELEMENT_NODE) {\n                        var siblingStyles = win.getComputedStyle(sibling);\n                        if (siblingStyles['display'] !== 'none') {\n                            return null;\n                        }\n                    } else if (sibling.nodeType === Node.TEXT_NODE && sibling.textContent.match(/\\S/)) {\n                        return null;\n                    }\n                };\n                elem = elem.parentNode;\n            }\n        },\n\n        renderContent: function() {\n            var that = this;\n            var renderData = this.highlight.contentRenderData;\n            if (renderData) {\n                _.each(renderData.data, function(data) {\n                    var $ancestor = $(data.ancestorEl);\n                    var $blockAncestor = $(data.blockAncestorEl);\n                    var document = data.ancestorEl.ownerDocument;\n\n                    var el = document.createElement(\"div\");\n                    el.style.position = 'absolute';\n                    el.style.top = (data.rect.top - renderData.top) + \"px\";\n                    el.style.left = (data.rect.left - renderData.left) + \"px\";\n                    el.style.width = (data.rect.width + 1) + \"px\";\n                    el.style.height = data.rect.height + \"px\";\n\n                    var copyStyles = function(copyFrom, copyTo) {\n                        _.each(CopiedTextStyles, function(styleName) {\n                            var style = copyFrom[styleName];\n                            if (style) {\n                                copyTo[styleName] = style;\n                            }\n                        });\n                    };\n\n                    var copiedStyles = $ancestor.data(\"rd-copied-text-styles\");\n                    if (!copiedStyles) {\n                        copiedStyles = {};\n                        var computedStyle = document.defaultView.getComputedStyle(data.ancestorEl);\n                        copyStyles(computedStyle, copiedStyles);\n                        $ancestor.data(\"rd-copied-text-styles\", copiedStyles);\n                    }\n\n                    var copiedFirstLineStyles = $blockAncestor.data(\"rd-copied-first-line-styles\");\n                    if (copiedFirstLineStyles === undefined) {\n                        copiedFirstLineStyles = null;\n                        var firstLineStyles = that.getFirstLineStyles(data.blockAncestorEl);\n                        if (firstLineStyles) {\n                            copiedFirstLineStyles = {};\n                            copyStyles(firstLineStyles, copiedFirstLineStyles);\n                            // Delete text-transform because it doesn't apply in Chrome on :first-line\n                            delete copiedFirstLineStyles['text-transform'];\n                            _.each([\"font-size\", \"letter-spacing\"], function(styleName) {\n                                if (copiedFirstLineStyles[styleName]) {\n                                    copiedFirstLineStyles[styleName] = that.lengthLib.toPx(data.ancestorEl, copiedFirstLineStyles[styleName]) + \"px\";\n                                }\n                            });\n                        }\n                        $blockAncestor.data(\"rd-copied-first-line-styles\", copiedFirstLineStyles);\n                    }\n\n                    if (copiedFirstLineStyles) {\n                        var textNode = that.getFirstTextNodeChild(data.blockAncestorEl);\n                        var range = document.createRange();\n                        range.setStart(textNode, 0);\n                        range.setEnd(data.node, data.startOffset + 1);\n                        var rects = range.getClientRects();\n                        var inferrer = new TextLineInferrer({\n                            lineHorizontalThreshold: $(\"body\", document).clientWidth,\n                            lineHorizontalLimit: document.defaultView.innerWidth\n                        });\n                        if (inferrer.inferLines(_.map(rects, function(rect) {\n                                return {\n                                    rect: rect\n                                }\n                            })).length > 1) {\n                            copiedFirstLineStyles = null;\n                        }\n                    }\n\n                    _.each(copiedStyles, function(style, styleName) {\n                        style = copiedFirstLineStyles ? copiedFirstLineStyles[styleName] || style : style;\n                        el.style[styleName] = style;\n                    });\n                    el.style[\"line-height\"] = data.rect.height + \"px\";\n\n                    el.appendChild(document.createTextNode(data.text));\n                    that.$el[0].appendChild(el);\n                });\n                processedElements = null;\n                computedStyles = null;\n            }\n        },\n\n        setCSS: function() {\n            // set highlight's absolute position\n            this.$el.css({\n                \"position\": \"absolute\",\n                \"top\": this.highlight.top + \"px\",\n                \"left\": this.highlight.left + \"px\",\n                \"height\": this.highlight.height + \"px\",\n                \"width\": this.highlight.width + \"px\"\n            });\n\n            // apply styles, if any\n            var styles = this.highlight.styles || {};\n            try {\n                this.$el.css(styles);\n            } catch (ex) {\n                console.log('EpubAnnotations: invalid css styles');\n            }\n        },\n\n        setBaseHighlight: function(removeFocus) {\n            var type = this.highlight.type;\n            this.$el.addClass(type);\n            this.$el.removeClass(\"hover-\" + type);\n            if (removeFocus) {\n                this.$el.removeClass(\"focused-\" + type);\n            }\n        },\n\n        setHoverHighlight: function() {\n            var type = this.highlight.type;\n            this.$el.addClass(\"hover-\" + type);\n            this.$el.removeClass(type);\n        },\n\n        setFocusedHighlight: function() {\n            var type = this.highlight.type;\n            this.$el.addClass(\"focused-\" + type);\n            this.$el.removeClass(type).removeClass(\"hover-\" + type);\n        },\n\n        setVisibility: function(value) {\n            if (value) {\n                this.$el.css('display', '');\n            } else {\n                this.$el.css('display', 'none');\n            }\n        },\n\n    });\n\n    return HighlightView;\n});\n\n",
    "define('readium_plugin_highlights/views/border_view',[\"./view\"], function(HighlightView) {\n\n    // This is not a backbone view.\n\n    var HighlightBorderView = HighlightView.extend({\n\n        template: \"<div class=\\\"rd-highlight-border\\\"></div>\",\n\n        setCSS: function() {\n\n            this.$el.css({\n                backgroundClip: 'padding-box',\n                borderStyle: 'solid',\n                borderWidth: '5px',\n                boxSizing: \"border-box\"\n            });\n            this._super();\n        },\n\n        setBaseHighlight: function() {\n\n            this.$el.addClass(\"highlight-border\");\n            this.$el.removeClass(\"hover-highlight-border\").removeClass(\"focused-highlight-border\");\n        },\n\n        setHoverHighlight: function() {\n\n            this.$el.addClass(\"hover-highlight-border\");\n            this.$el.removeClass(\"highlight-border\");\n        },\n\n        setFocusedHighlight: function() {\n            this.$el.addClass('focused-highlight-border');\n            this.$el.removeClass('highlight-border').removeClass('hover-highlight-border');\n        }\n    });\n\n    return HighlightBorderView;\n});\n\n",
    "define('readium_plugin_highlights/models/group',[\"jquery\", \"underscore\", \"../lib/class\", \"./text_line_inferrer\", \"../views/view\", \"../views/border_view\", \"../helpers\"],\nfunction($, _, Class, TextLineInferrer, HighlightView, HighlightBorderView, HighlightHelpers) {\n\n    var debouncedTrigger = _.debounce(\n        function(fn, eventName) {\n            fn(eventName);\n        }, 10);\n\n    var HighlightGroup = Class.extend({\n\n        init: function(context, options) {\n            this.context = context;\n\n            this.highlightViews = [];\n\n            this.CFI = options.CFI;\n            this.selectedNodes = options.selectedNodes;\n            this.offsetTopAddition = options.offsetTopAddition;\n            this.offsetLeftAddition = options.offsetLeftAddition;\n            this.styles = options.styles;\n            this.id = options.id;\n            this.type = options.type;\n            this.scale = options.scale;\n            this.selectionText = options.selectionText;\n            this.visible = options.visible;\n            this.rangeInfo = options.rangeInfo;\n\n            this.constructHighlightViews();\n        },\n\n        onHighlightEvent: function(event, type) {\n            var that = this;\n            var documentFrame = this.context.iframe;\n            var topView = this.context.manager;\n            var triggerEvent = _.partial(topView.trigger, _, that.type,\n                that.CFI, that.id, event, documentFrame);\n\n            if (type === \"click\" || type === \"touchend\") {\n                debouncedTrigger(triggerEvent, \"annotationClicked\");\n\n            } else if (type === \"contextmenu\") {\n                triggerEvent(\"annotationRightClicked\");\n\n            } else if (type === \"mousemove\") {\n                triggerEvent(\"annotationMouseMove\");\n\n            } else if (type === \"mouseenter\") {\n                triggerEvent(\"annotationHoverIn\");\n\n            } else if (type === \"mouseleave\") {\n                triggerEvent(\"annotationHoverOut\");\n\n            } else if (type === \"mousedown\") {\n                // prevent selection when right clicking\n                var preventEvent = function(event) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    documentFrame.contentDocument.removeEventListener(event.type, preventEvent);\n                };\n                if (event.button === 2) {\n                    event.preventDefault();\n                    documentFrame.contentDocument.addEventListener(\"selectstart\", preventEvent);\n                    documentFrame.contentDocument.addEventListener(\"mouseup\", preventEvent);\n                    documentFrame.contentDocument.addEventListener(\"click\", preventEvent);\n                    documentFrame.contentDocument.addEventListener(\"contextmenu\", preventEvent);\n                }\n            }\n\n            // \"mouseenter\" and \"mouseleave\" events not only trigger corresponding named event, but also\n            // affect the appearance\n            if (type === \"mouseenter\" || type === \"mouseleave\") {\n                // Change appearance of highlightViews constituting this highlight group\n                // do not iterate over secondary highlight views (hightlightViewsSecondary)\n                _.each(this.highlightViews, function(highlightView) {\n\n                    if (type === \"mouseenter\") {\n                        highlightView.setHoverHighlight();\n                    } else if (type === \"mouseleave\") {\n                        highlightView.setBaseHighlight(false);\n                    }\n                });\n            }\n\n        },\n\n        normalizeRectangle: function(rect) {\n            return {\n                left: rect.left,\n                right: rect.right,\n                top: rect.top,\n                bottom: rect.bottom,\n                width: rect.right - rect.left,\n                height: rect.bottom - rect.top\n            };\n        },\n\n        // produces an event string corresponding to \"pointer events\" that we want to monitor on the\n        // bound HL container. We are adding namespace to the event names in order to be able to\n        // remove them by specifying <eventname>.<namespace> only, rather than classic callback function\n        getBoundHighlightContainerEvents: function() {\n            // these are the event names that we handle in \"onHighlightEvent\"\n            var boundHighlightContainerEvents = [\"click\", \"touchstart\", \"touchend\", \"touchmove\", \"contextmenu\",\n                \"mouseenter\", \"mouseleave\", \"mousemove\", \"mousedown\"\n            ];\n            var namespace = \".rdjsam-\" + this.id;\n            return boundHighlightContainerEvents.map(function(e) {\n                return e + namespace;\n            }).join(\" \");\n        },\n\n        getFirstBlockParent: function(elem) {\n            var win = elem.ownerDocument.defaultView;\n            do {\n                var style = win.getComputedStyle(elem);\n                if (style['display'] !== 'inline') {\n                    return elem;\n                }\n            } while (elem = elem.parentNode);\n        },\n\n        // construct view for each rectangle constituting HL group\n        constructHighlightViews: function() {\n            var that = this;\n            if (!this.visible)\n                return;\n\n            var rectTextList = [];\n\n            // this is an array of elements (not Node.TEXT_NODE) that are part of HL group\n            // they will presented as HighlightBorderView\n            var rectElementList = [];\n            var inferrer;\n            var inferredLines;\n            var allContainerRects = [];\n            var hoverThreshold = 2; // Pixels to expand each rect on each side, for hovering/clicking purposes\n            var rangeInfo = this.rangeInfo;\n            var selectedNodes = this.selectedNodes;\n            var includeMedia = this.includeMedia;\n            var contentDocumentFrame = this.context.iframe;\n            var highlightStyles = this.styles;\n            var cloneTextMode = highlightStyles ? highlightStyles['-rd-highlight-mode'] === 'clone-text' : false;\n\n            function pushToRectTextList(range) {\n                var match,\n                    rangeText = range.toString(),\n                    rects = [],\n                    node = range.startContainer,\n                    ancestor = range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE ? range.commonAncestorContainer : range.commonAncestorContainer.parentNode,\n                    blockAncestor = that.getFirstBlockParent(ancestor),\n                    baseOffset = range.startOffset,\n                    rgx = /\\S+/g;\n\n                if (cloneTextMode) {\n                    while (match = rgx.exec(rangeText)) {\n                        var startOffset = baseOffset + rgx.lastIndex - match[0].length,\n                            endOffset = baseOffset + rgx.lastIndex;\n                        range.setStart(node, startOffset);\n                        range.setEnd(node, endOffset);\n                        var clientRects = range.getClientRects();\n                        var curRect = 0;\n                        var curStart = startOffset;\n                        var curEnd = curStart;\n                        while (curRect < clientRects.length) {\n                            var saveRect = false;\n                            if (clientRects[curRect].width === 0 || clientRects[curRect].height === 0) {\n                                curRect++;\n                                continue;\n                            }\n                            if (curRect === clientRects.length - 1) {\n                                curEnd = endOffset;\n                                saveRect = true;\n                            } else {\n                                curEnd++;\n                                range.setStart(node, curStart);\n                                range.setEnd(node, curEnd);\n                                var tempRects = range.getClientRects();\n                                var tempRect = tempRects[0];\n                                // Skip over empty first rect if there is one\n                                if (tempRects.length > 1 && (tempRect.width === 0 || tempRect.height === 0)) {\n                                    tempRect = tempRects[1];\n                                }\n                                var differences = 0;\n                                _.each([\"top\", \"left\", \"bottom\", \"right\"], function(prop) {\n                                    differences += (tempRects[0][prop] !== clientRects[curRect][prop] ? 1 : 0);\n                                });\n                                if (differences === 0) {\n                                    saveRect = true;\n                                }\n                            }\n                            if (saveRect) {\n                                rects.push({\n                                    rect: clientRects[curRect],\n                                    text: node.textContent.substring(curStart, curEnd),\n                                    node: node,\n                                    startOffset: curStart\n                                });\n                                curRect++;\n                                curStart = curEnd;\n                            }\n                        }\n                    }\n                } else {\n                    _.each(range.getClientRects(), function(rect) {\n                        rects.push({\n                            rect: rect,\n                            text: rangeText\n                        });\n                    });\n                }\n                _.each(rects, function(rect) {\n                    var normalizedRect = that.normalizeRectangle(rect.rect);\n\n                    //filter out empty rectangles\n                    if (normalizedRect.width === 0 || normalizedRect.height === 0) {\n                        return;\n                    }\n\n                    // push both rect and ancestor in the list\n                    rectTextList.push({\n                        rect: normalizedRect,\n                        text: rect.text,\n                        ancestorEl: ancestor,\n                        blockAncestorEl: blockAncestor,\n                        node: rect.node,\n                        startOffset: rect.startOffset\n                    });\n                });\n            }\n\n            // if range is within one node\n            if (rangeInfo && rangeInfo.startNode === rangeInfo.endNode) {\n                var node = rangeInfo.startNode;\n                var range = that.context.document.createRange();\n                range.setStart(node, rangeInfo.startOffset);\n                range.setEnd(node, rangeInfo.endOffset);\n\n                // we are only interested in TEXT_NODE\n                if (node.nodeType === Node.TEXT_NODE) {\n                    // get client rectangles for the range and push them into rectTextList\n                    pushToRectTextList(range);\n                    selectedNodes = [];\n                }\n            }\n\n            // multi-node range, for each selected node\n            _.each(selectedNodes, function(node) {\n                // create new Range\n                var range = that.context.document.createRange();\n                if (node.nodeType === Node.TEXT_NODE) {\n                    if (rangeInfo && node === rangeInfo.startNode && rangeInfo.startOffset !== 0) {\n                        range.setStart(node, rangeInfo.startOffset);\n                        range.setEnd(node, node.length);\n                    } else if (rangeInfo && node === rangeInfo.endNode && rangeInfo.endOffset !== 0) {\n                        range.setStart(node, 0);\n                        range.setEnd(node, rangeInfo.endOffset);\n                    } else {\n                        range.selectNodeContents(node);\n                    }\n\n                    // for each client rectangle\n                    pushToRectTextList(range);\n                } else if (node.nodeType === Node.ELEMENT_NODE && includeMedia) {\n                    // non-text node element\n                    // if we support this elements in the HL group\n                    if (_.contains([\"img\", \"video\", \"audio\"], node.tagName.toLowerCase())) {\n                        // set the Range to contain the node and its contents and push rectangle to the list\n                        range.selectNode(node);\n                        rectElementList.push(range.getBoundingClientRect());\n                    }\n                }\n            });\n\n            var $html = $(that.context.document.documentElement);\n\n            function calculateScale() {\n                var scale = that.scale;\n                //is there a transform scale for the content document?\n                var matrix = HighlightHelpers.getMatrix($html);\n                if (!matrix && (that.context.isIe9 || that.context.isIe10)) {\n                    //if there's no transform scale then set the scale as the IE zoom factor\n                    scale = (window.screen.deviceXDPI / 96); //96dpi == 100% scale\n                } else if (matrix) {\n                    scale = HighlightHelpers.getScaleFromMatrix(matrix);\n                }\n                return scale;\n            }\n\n            var scale = calculateScale();\n\n            inferrer = new TextLineInferrer({\n                lineHorizontalThreshold: $(\"body\", $html).clientWidth,\n                lineHorizontalLimit: contentDocumentFrame.contentWindow.innerWidth\n            });\n\n            // only take \"rect\" property when inferring lines\n            inferredLines = inferrer.inferLines(rectTextList);\n            _.each(inferredLines, function(line, index) {\n                var renderData = line.data;\n                //console.log(line.data);\n                line = line.line;\n                var highlightTop = (line.startTop + that.offsetTopAddition) / scale;\n                var highlightLeft = (line.left + that.offsetLeftAddition) / scale;\n                var highlightHeight = line.avgHeight / scale;\n                var highlightWidth = line.width / scale;\n                allContainerRects.push({\n                    top: highlightTop - hoverThreshold,\n                    left: highlightLeft - hoverThreshold,\n                    bottom: highlightTop + highlightHeight + hoverThreshold * 2,\n                    right: highlightLeft + highlightWidth + hoverThreshold * 2,\n                });\n\n                var highlightView = new HighlightView(that.context, {\n                    id: that.id,\n                    CFI: that.CFI,\n                    type: that.type,\n                    top: highlightTop,\n                    left: highlightLeft,\n                    height: highlightHeight,\n                    width: highlightWidth,\n                    styles: _.extend({\n                        \"z-index\": \"1000\",\n                        \"pointer-events\": \"none\"\n                    }, highlightStyles),\n                    contentRenderData: cloneTextMode ? {\n                        data: renderData,\n                        top: line.startTop,\n                        left: line.left\n                    } : null\n                });\n\n                that.highlightViews.push(highlightView);\n            });\n\n            // deal with non TEXT_NODE elements\n            _.each(rectElementList, function(rect) {\n                var highlightTop = (rect.top + that.offsetTopAddition) / scale;\n                var highlightLeft = (rect.left + that.offsetLeftAddition) / scale;\n                var highlightHeight = rect.height / scale;\n                var highlightWidth = rect.width / scale;\n                allContainerRects.push({\n                    top: highlightTop - hoverThreshold,\n                    left: highlightLeft - hoverThreshold,\n                    bottom: highlightTop + highlightHeight + hoverThreshold * 2,\n                    right: highlightLeft + highlightWidth + hoverThreshold * 2,\n                });\n\n                var highlightView = new HighlightBorderView(this.context, {\n                    highlightId: that.id,\n                    CFI: that.CFI,\n                    top: highlightTop,\n                    left: highlightLeft,\n                    height: highlightHeight,\n                    width: highlightWidth,\n                    styles: highlightStyles\n                });\n\n                that.highlightViews.push(highlightView);\n            });\n\n            // this is a flag indicating if mouse is currently within the boundary of HL group\n            var mouseEntered = false;\n\n            // helper function to test if a point is within a rectangle\n            function pointRectangleIntersection(point, rect) {\n                return point.x > rect.left && point.x < rect.right &&\n                    point.y > rect.top && point.y < rect.bottom;\n            };\n\n            that.boundHighlightCallback = function(e) {\n                var scale = calculateScale();\n                var mouseIsInside = false;\n\n                var x = e.pageX;\n                var y = e.pageY;\n\n                if (e.type === 'touchend') {\n                    var lastTouch = _.last(e.changedTouches);\n                    x = lastTouch.pageX;\n                    y = lastTouch.pageY;\n                }\n\n                var point = {\n                    x: (x + that.offsetLeftAddition) / scale,\n                    y: (y + that.offsetTopAddition) / scale\n                };\n\n                _.each(allContainerRects, function(rect) {\n\n                    if (pointRectangleIntersection(point, rect)) {\n                        mouseIsInside = true;\n                        // if event is \"click\" and there is an active selection\n                        if (e.type === \"click\") {\n                            var sel = e.target.ownerDocument.getSelection();\n                            // had to add this check to make sure that rangeCount is not 0\n                            if (sel && sel.rangeCount && !sel.getRangeAt(0).collapsed) {\n                                //do not trigger a click when there is an active selection\n                                return;\n                            }\n                        }\n\n                        var isTouchEvent = e.type.indexOf('touch') !== -1;\n\n                        if (isTouchEvent) {\n                            // call \"normal\" event handler for HL group to touch capable devices\n                            that.onHighlightEvent(e, e.type);\n                        }\n\n                        // if this is the first time we are mouse entering in the area\n                        if (!mouseEntered) {\n                            // regardless of the actual event type we want highlightGroupCallback process \"mouseenter\"\n                            that.onHighlightEvent(e, \"mouseenter\");\n\n                            // set flag indicating that we are in HL group confines\n                            mouseEntered = true;\n                            return;\n                        } else if (!isTouchEvent) {\n                            // call \"normal\" event handler for HL group to desktop devices\n                            that.onHighlightEvent(e, e.type);\n                        }\n                    }\n                });\n\n                if (!mouseIsInside && mouseEntered) {\n                    // set flag indicating that we left HL group confines\n                    mouseEntered = false;\n                    that.onHighlightEvent(e, \"mouseleave\");\n                }\n            };\n            that.boundHighlightElement = $html;\n            $html.on(this.getBoundHighlightContainerEvents(), that.boundHighlightCallback);\n        },\n\n        resetHighlights: function(viewportElement, offsetTop, offsetLeft) {\n            this.offsetTopAddition = offsetTop;\n            this.offsetLeftAddition = offsetLeft;\n            this.destroyCurrentHighlights();\n            this.constructHighlightViews();\n            this.renderHighlights(viewportElement);\n        },\n\n        destroyCurrentHighlights: function() {\n            var that = this;\n            _.each(this.highlightViews, function(highlightView) {\n                highlightView.remove();\n            });\n\n            var events = that.getBoundHighlightContainerEvents();\n            var $el = this.boundHighlightElement;\n            if ($el) {\n                $el.off(events, this.boundHighlightCallback);\n            }\n\n            this.boundHighlightCallback = null;\n            this.boundHighlightElement = null;\n\n            this.highlightViews.length = 0;\n        },\n\n        renderHighlights: function(viewportElement) {\n            // higlight group is live, it just doesn't need to be visible, yet.\n            if (!this.visible) {\n                return;\n            }\n\n            _.each(this.highlightViews, function(view, index) {\n                $(viewportElement).append(view.render());\n            });\n        },\n\n        toInfo: function() {\n            // get array of rectangles for all the HightligtViews\n            var rectangleArray = [];\n            var offsetTopAddition = this.offsetTopAddition;\n            var offsetLeftAddition = this.offsetLeftAddition;\n            var scale = this.scale;\n            _.each(this.highlightViews, function(view, index) {\n                var hl = view.highlight;\n                rectangleArray.push({\n                    top: (hl.top - offsetTopAddition) * scale,\n                    left: (hl.left - offsetLeftAddition) * scale,\n                    height: hl.height * scale,\n                    width: hl.width * scale\n                });\n            });\n\n            return {\n                id: this.id,\n                type: this.type,\n                CFI: this.CFI,\n                rectangleArray: rectangleArray,\n                selectedText: this.selectionText\n            };\n        },\n\n        setStyles: function(styles) {\n            this.styles = styles;\n            _.each(this.highlightViews, function(view, index) {\n                view.setStyles(styles);\n            });\n        },\n\n        update: function(type, styles) {\n            this.type = type;\n            this.styles = styles;\n\n            // for each View of the HightlightGroup\n            _.each(this.highlightViews, function(view, index) {\n                view.update(type, styles);\n            });\n        },\n\n        setState: function(state, value) {\n            _.each(this.highlightViews, function(view, index) {\n                if (state === \"hover\") {\n                    if (value) {\n                        view.setHoverHighlight();\n                    } else {\n                        view.setBaseHighlight(false);\n                    }\n                } else if (state === \"visible\") {\n                    view.setVisibility(value);\n                } else if (state === \"focused\") {\n                    if (value) {\n                        view.setFocusedHighlight();\n                    } else {\n                        view.setBaseHighlight(true);\n                    }\n\n                }\n            });\n        }\n    });\n\n    return HighlightGroup;\n});\n\n",
    "define('readium_plugin_highlights/controller',[\"jquery\", \"underscore\", \"./lib/class\", \"./helpers\", \"./models/group\"],\nfunction($, _, Class, HighlightHelpers, HighlightGroup) {\n    var HighlightsController = Class.extend({\n\n        highlights: [],\n        annotationHash: {},\n        offsetTopAddition: 0,\n        offsetLeftAddition: 0,\n        readerBoundElement: undefined,\n        scale: 0,\n\n        init: function(context, options) {\n            this.context = context;\n\n            this.epubCFI = EPUBcfi;\n            this.readerBoundElement = this.context.document.documentElement;\n\n            if (options.getVisibleCfiRangeFn) {\n                this.getVisibleCfiRange = options.getVisibleCfiRangeFn;\n            }\n\n            // inject annotation CSS into iframe\n            if (this.context.cssUrl) {\n                this._injectAnnotationCSS(this.context.cssUrl);\n            }\n\n            // emit an event when user selects some text.\n            var that = this;\n            this.context.document.addEventListener(\"mouseup\", function(event) {\n                var range = that._getCurrentSelectionRange();\n                if (range === undefined) {\n                    return;\n                }\n                if (range.startOffset - range.endOffset) {\n                    that.context.manager.trigger(\"textSelectionEvent\", event, range, that.context.iframe);\n                }\n            });\n\n            if (!rangy.initialized) {\n                rangy.init();\n            }\n        },\n\n        getVisibleCfiRange: function() {\n            // returns {firstVisibleCfi: <>, lastVisibleCfi: <>}\n            // implemented in Readium.ReaderView, passed in via options\n        },\n\n        // ------------------------------------------------------------------------------------ //\n        //  \"PUBLIC\" METHODS (THE API)                                                          //\n        // ------------------------------------------------------------------------------------ //\n\n        redraw: function() {\n            var that = this;\n\n            var leftAddition = -this._getPaginationLeftOffset();\n            \n            var isVerticalWritingMode = this.context.paginationInfo().isVerticalWritingMode;\n\n            var visibleCfiRange = this.getVisibleCfiRange();\n\n            // Highlights\n            _.each(this.highlights, function(highlightGroup) {\n                var visible = true;\n\n                if (visibleCfiRange &&\n                    visibleCfiRange.firstVisibleCfi &&\n                    visibleCfiRange.firstVisibleCfi.contentCFI &&\n                    visibleCfiRange.lastVisibleCfi &&\n                    visibleCfiRange.lastVisibleCfi.contentCFI) {\n\n                    visible = that._cfiIsBetweenTwoCfis(\n                        highlightGroup.CFI,\n                        visibleCfiRange.firstVisibleCfi.contentCFI,\n                        visibleCfiRange.lastVisibleCfi.contentCFI);\n                }\n                highlightGroup.visible = visible;\n                highlightGroup.resetHighlights(that.readerBoundElement,\n                    isVerticalWritingMode ? leftAddition : 0,\n                    isVerticalWritingMode ? 0 : leftAddition\n                    );\n\n            });\n        },\n\n        getHighlight: function(id) {\n            var highlight = this.annotationHash[id];\n            if (highlight) {\n                return highlight.toInfo();\n            } else {\n                return undefined;\n            }\n        },\n\n        getHighlights: function() {\n            var highlights = [];\n            _.each(this.highlights, function(highlight) {\n                highlights.push(highlight.toInfo());\n            });\n            return highlights;\n        },\n\n        removeHighlight: function(annotationId) {\n            var annotationHash = this.annotationHash;\n            var highlights = this.highlights;\n\n            delete annotationHash[annotationId];\n\n            highlights = _.reject(highlights, function(highlightGroup) {\n                if (highlightGroup.id == annotationId) {\n                    highlightGroup.destroyCurrentHighlights();\n                    return true;\n                } else {\n                    return false;\n                }\n            });\n\n            this.highlights = highlights;\n        },\n\n        removeHighlightsByType: function(type) {\n            var annotationHash = this.annotationHash;\n            var highlights = this.highlights;\n\n            // the returned list only contains HLs for which the function returns false\n            highlights = _.reject(highlights, function(highlightGroup) {\n                if (highlightGroup.type === type) {\n                    delete annotationHash[highlightGroup.id];\n                    highlightGroup.destroyCurrentHighlights();\n                    return true;\n                } else {\n                    return false;\n                }\n            });\n\n            this.highlights = highlights;\n        },\n\n        // generate unique prefix for HL ids\n        generateIdPrefix: function() {\n            var idPrefix = 'xxxxxxxx'.replace(/[x]/g, function(c) {\n                var r = Math.random() * 16 | 0;\n                return r.toString(16);\n            });\n            idPrefix += \"_\";\n            return idPrefix;\n        },\n\n\n        // takes partial CFI as parameter\n        addHighlight: function(CFI, id, type, styles) {\n            var CFIRangeInfo;\n            var range;\n            var rangeStartNode;\n            var rangeEndNode;\n            var selectedElements;\n            var leftAddition;\n\n            var contentDoc = this.context.document;\n            //get transform scale of content document\n            var scale = 1.0;\n            var matrix = HighlightHelpers.getMatrix($('html', contentDoc));\n            if (matrix) {\n                scale = HighlightHelpers.getScaleFromMatrix(matrix);\n            }\n\n            //create a dummy test div to determine if the browser provides\n            // client rectangles that take transform scaling into consideration\n            var $div = $('<div style=\"font-size: 50px; position: absolute; background: red; top:-9001px;\">##</div>');\n            $(contentDoc.documentElement).append($div);\n            range = contentDoc.createRange();\n            range.selectNode($div[0]);\n            var renderedWidth = this._normalizeRectangle(range.getBoundingClientRect()).width;\n            var clientWidth = $div[0].clientWidth;\n            $div.remove();\n            var renderedVsClientWidthFactor = renderedWidth / clientWidth;\n            if (renderedVsClientWidthFactor === 1) {\n                //browser doesn't provide scaled client rectangles (firefox)\n                scale = 1;\n            } else if (this.context.isIe9 || this.context.isIe10) {\n                //use the test scale factor as our scale value for IE 9/10\n                scale = renderedVsClientWidthFactor;\n            }\n            this.scale = scale;\n\n            // form fake full CFI to satisfy getRangeTargetNodes\n            var arbitraryPackageDocCFI = \"/99!\"\n            var fullFakeCFI = \"epubcfi(\" + arbitraryPackageDocCFI + CFI + \")\";\n            if (this.epubCFI.Interpreter.isRangeCfi(fullFakeCFI)) {\n                CFIRangeInfo = this.epubCFI.getRangeTargetElements(fullFakeCFI, contentDoc, [\"cfi-marker\", \"cfi-blacklist\", \"mo-cfi-highlight\"], [], [\"MathJax_Message\", \"MathJax_SVG_Hidden\"]);\n\n                var startNode = CFIRangeInfo.startElement,\n                    endNode = CFIRangeInfo.endElement;\n                range = rangy.createRange(contentDoc);\n                if (startNode.length < CFIRangeInfo.startOffset) {\n                    //this is a workaround\n                    // \"Uncaught IndexSizeError: Index or size was negative, or greater than the allowed value.\" errors\n                    // the range cfi generator outputs a cfi like /4/2,/1:125,/16\n                    // can't explain, investigating..\n                    CFIRangeInfo.startOffset = startNode.length;\n                }\n                range.setStart(startNode, CFIRangeInfo.startOffset);\n                range.setEnd(endNode, CFIRangeInfo.endOffset);\n                selectedElements = range.getNodes();\n            } else {\n                var element = this.epubCFI.getTargetElement(fullFakeCFI, contentDoc, [\"cfi-marker\", \"cfi-blacklist\", \"mo-cfi-highlight\"], [], [\"MathJax_Message\", \"MathJax_SVG_Hidden\"]);\n                selectedElements = [element ? element[0] : null];\n                range = null;\n            }\n\n            leftAddition = -this._getPaginationLeftOffset();\n\n            var isVerticalWritingMode = this.context.paginationInfo().isVerticalWritingMode;\n\n            this._addHighlightHelper(\n                CFI, id, type, styles, selectedElements, range,\n                startNode, endNode,\n                isVerticalWritingMode ? leftAddition : 0,\n                isVerticalWritingMode ? 0 : leftAddition\n                );\n\n            return {\n                selectedElements: selectedElements,\n                CFI: CFI\n            };\n        },\n\n\n        // this returns a partial CFI only!!\n        getCurrentSelectionCFI: function() {\n            var currentSelection = this._getCurrentSelectionRange();\n            var CFI;\n            if (currentSelection) {\n                selectionInfo = this._getSelectionInfo(currentSelection);\n                CFI = selectionInfo.CFI;\n            }\n\n            return CFI;\n        },\n\n        // this returns a partial CFI only!!\n        getCurrentSelectionOffsetCFI: function() {\n            var currentSelection = this._getCurrentSelectionRange();\n\n            var CFI;\n            if (currentSelection) {\n                CFI = this._generateCharOffsetCFI(currentSelection);\n            }\n            return CFI;\n        },\n\n        addSelectionHighlight: function(id, type, styles, clearSelection) {\n            var CFI = this.getCurrentSelectionCFI();\n            if (CFI) {\n\n                // if clearSelection is true\n                if (clearSelection) {\n                    var iframeDocument = this.context.document;\n                    if (iframeDocument.getSelection) {\n                        var currentSelection = iframeDocument.getSelection();\n                        currentSelection.collapseToStart();\n                    }\n                }\n                return this.addHighlight(CFI, id, type, styles);\n            } else {\n                throw new Error(\"Nothing selected\");\n            }\n        },\n\n        updateAnnotation: function(id, type, styles) {\n            var annotationViews = this.annotationHash[id];\n            if (annotationViews) {\n                annotationViews.update(type, styles);\n            }\n            return annotationViews;\n        },\n\n        replaceAnnotation: function(id, cfi, type, styles) {\n            var annotationViews = this.annotationHash[id];\n            if (annotationViews) {\n                // remove an existing annotatio\n                this.removeHighlight(id);\n\n                // create a new HL\n                this.addHighlight(cfi, id, type, styles);\n            }\n            return annotationViews;\n        },\n\n        updateAnnotationView: function(id, styles) {\n            var annotationViews = this.annotationHash[id];\n            if (annotationViews) {\n                annotationViews.setStyles(styles);\n            }\n            return annotationViews;\n        },\n\n        setAnnotationViewState: function(id, state, value) {\n            var annotationViews = this.annotationHash[id];\n            if (annotationViews) {\n                annotationViews.setState(state, value);\n            }\n            return annotationViews;\n        },\n\n        setAnnotationViewStateForAll: function(state, value) {\n            var annotationViews = this.annotationHash;\n            _.each(annotationViews, function(annotationView) {\n                annotationView.setState(state, value);\n            });\n        },\n\n        // ------------------------------------------------------------------------------------ //\n        //  \"PRIVATE\" HELPERS                                                                   //\n        // ------------------------------------------------------------------------------------ //\n\n\n\n        //return an array of all numbers in the content cfi\n        _parseContentCfi: function(cont) {\n            return cont.replace(/\\[(.*?)\\]/, \"\").split(/[\\/,:]/).map(function(n) {\n                return parseInt(n);\n            }).filter(Boolean);\n        },\n\n        _contentCfiComparator: function(cont1, cont2) {\n            cont1 = this._parseContentCfi(cont1);\n            cont2 = this._parseContentCfi(cont2);\n\n            //compare cont arrays looking for differences\n            for (var i = 0; i < cont1.length; i++) {\n                if (cont1[i] > cont2[i]) {\n                    return 1;\n                } else if (cont1[i] < cont2[i]) {\n                    return -1;\n                }\n            }\n\n            //no differences found, so confirm that cont2 did not have values we didn't check\n            if (cont1.length < cont2.length) {\n                return -1;\n            }\n\n            //cont arrays are identical\n            return 0;\n        },\n\n        // determine if a given Cfi falls between two other cfis.2\n        _cfiIsBetweenTwoCfis: function(cfi, firstVisibleCfi, lastVisibleCfi) {\n            if (!firstVisibleCfi || !lastVisibleCfi) {\n                return null;\n            }\n            var first = this._contentCfiComparator(cfi, firstVisibleCfi);\n            var second = this._contentCfiComparator(cfi, lastVisibleCfi);\n            return first >= 0 && second <= 0;\n        },\n\n        _addHighlightHelper: function(CFI, annotationId, type, styles, highlightedNodes,\n            range, startNode, endNode, offsetTop, offsetLeft) {\n            if (!offsetTop) {\n                offsetTop = this.offsetTopAddition;\n            }\n            if (!offsetLeft) {\n                offsetLeft = this.offsetLeftAddition;\n            }\n\n            var visible;\n            // check if the options specify lastVisibleCfi/firstVisibleCfi. If they don't fall back to displaying the highlights anyway.\n            var visibleCfiRange = this.getVisibleCfiRange();\n            if (visibleCfiRange &&\n                visibleCfiRange.firstVisibleCfi &&\n                visibleCfiRange.firstVisibleCfi.contentCFI &&\n                visibleCfiRange.lastVisibleCfi &&\n                visibleCfiRange.lastVisibleCfi.contentCFI) {\n                visible = this._cfiIsBetweenTwoCfis(CFI, visibleCfiRange.firstVisibleCfi.contentCFI, visibleCfiRange.lastVisibleCfi.contentCFI);\n            } else {\n                visible = true;\n            }\n\n            annotationId = annotationId.toString();\n            if (this.annotationHash[annotationId]) {\n                throw new Error(\"That annotation id already exists; annotation not added\");\n            }\n\n            var highlightGroup = new HighlightGroup(this.context, {\n                CFI: CFI,\n                selectedNodes: highlightedNodes,\n                offsetTopAddition: offsetTop,\n                offsetLeftAddition: offsetLeft,\n                styles: styles,\n                id: annotationId,\n                type: type,\n                scale: this.scale,\n                selectionText: range ? range.toString() : \"\",\n                visible: visible,\n                rangeInfo: range ? {\n                    startNode: startNode,\n                    startOffset: range.startOffset,\n                    endNode: endNode,\n                    endOffset: range.endOffset\n                } : null\n            });\n\n            this.annotationHash[annotationId] = highlightGroup;\n            this.highlights.push(highlightGroup);\n\n\n            highlightGroup.renderHighlights(this.readerBoundElement);\n        },\n\n        _normalizeRectangle: function(rect) {\n            return {\n                left: rect.left,\n                right: rect.right,\n                top: rect.top,\n                bottom: rect.bottom,\n                width: rect.right - rect.left,\n                height: rect.bottom - rect.top\n            };\n        },\n\n        _getSelectionInfo: function(selectedRange, elementType) {\n            // Generate CFI for selected text\n            var CFI = this._generateRangeCFI(selectedRange);\n            var intervalState = {\n                startElementFound: false,\n                endElementFound: false\n            };\n            var selectedElements = [];\n\n            if (!elementType) {\n                var elementType = [\"text\"];\n            }\n\n            this._findSelectedElements(\n                selectedRange.commonAncestorContainer,\n                selectedRange.startContainer,\n                selectedRange.endContainer,\n                intervalState,\n                selectedElements,\n                elementType\n            );\n\n            // Return a list of selected text nodes and the CFI\n            return {\n                CFI: CFI,\n                selectedElements: selectedElements\n            };\n        },\n\n        _generateRangeCFI: function(selectedRange) {\n            var startNode = selectedRange.startContainer;\n            var endNode = selectedRange.endContainer;\n            var commonAncestor = selectedRange.commonAncestorContainer;\n            var startOffset;\n            var endOffset;\n            var rangeCFIComponent;\n\n            startOffset = selectedRange.startOffset;\n            endOffset = selectedRange.endOffset;\n\n            rangeCFIComponent = this.epubCFI.generateRangeComponent(\n                startNode,\n                startOffset,\n                endNode,\n                endOffset, [\"cfi-marker\", \"cfi-blacklist\", \"mo-cfi-highlight\"], [], [\"MathJax_Message\", \"MathJax_SVG_Hidden\"]\n            );\n            return rangeCFIComponent;\n        },\n\n        _generateCharOffsetCFI: function(selectedRange) {\n            // Character offset\n            var startNode = selectedRange.startContainer;\n            var startOffset = selectedRange.startOffset;\n            var charOffsetCFI;\n\n            if (startNode.nodeType === Node.TEXT_NODE) {\n                charOffsetCFI = this.epubCFI.generateCharacterOffsetCFIComponent(\n                    startNode,\n                    startOffset, [\"cfi-marker\", \"cfi-blacklist\", \"mo-cfi-highlight\"], [], [\"MathJax_Message\", \"MathJax_SVG_Hidden\"]\n                );\n            }\n            return charOffsetCFI;\n        },\n\n        // REFACTORING CANDIDATE: Convert this to jquery\n        _findSelectedElements: function(\n            currElement, startElement, endElement, intervalState, selectedElements, elementTypes) {\n\n            if (currElement === startElement) {\n                intervalState.startElementFound = true;\n            }\n\n            if (intervalState.startElementFound === true) {\n                this._addElement(currElement, selectedElements, elementTypes);\n            }\n\n            if (currElement === endElement) {\n                intervalState.endElementFound = true;\n                return;\n            }\n\n            if (currElement.firstChild) {\n                this._findSelectedElements(currElement.firstChild, startElement, endElement,\n                    intervalState, selectedElements, elementTypes);\n                if (intervalState.endElementFound) {\n                    return;\n                }\n            }\n\n            if (currElement.nextSibling) {\n                this._findSelectedElements(currElement.nextSibling, startElement, endElement,\n                    intervalState, selectedElements, elementTypes);\n                if (intervalState.endElementFound) {\n                    return;\n                }\n            }\n        },\n\n        _addElement: function(currElement, selectedElements, elementTypes) {\n            // Check if the node is one of the types\n            _.each(elementTypes, function(elementType) {\n\n                if (elementType === \"text\") {\n                    if (currElement.nodeType === Node.TEXT_NODE) {\n                        selectedElements.push(currElement);\n                    }\n                } else {\n                    if ($(currElement).is(elementType)) {\n                        selectedElements.push(currElement);\n                    }\n                }\n            });\n        },\n\n        // Rationale: This is a cross-browser method to get the currently selected text\n        _getCurrentSelectionRange: function() {\n            var currentSelection;\n            var iframeDocument = this.context.document;\n            if (iframeDocument.getSelection) {\n\n                currentSelection = iframeDocument.getSelection();\n                if (!currentSelection || currentSelection.rangeCount === 0) {\n                    return undefined;\n                }\n\n                var range = currentSelection.getRangeAt(0);\n\n                if (range.toString() !== '') {\n                    return range;\n                } else {\n                    return undefined;\n                }\n            } else if (iframeDocument.selection) {\n                return iframeDocument.selection.createRange();\n            } else {\n                return undefined;\n            }\n        },\n\n        _getPaginationLeftOffset: function() {\n        \n            var $htmlElement = $(this.context.document.documentElement);\n            if (!$htmlElement || !$htmlElement.length) {\n                // if there is no html element, we might be dealing with a fxl with a svg spine item\n                return 0;\n            }\n\n            var offsetLeftPixels = $htmlElement.css(this.context.paginationInfo().isVerticalWritingMode ? \"top\" : (this.context.isRTL ? \"right\" : \"left\"));\n            var offsetLeft = parseInt(offsetLeftPixels.replace(\"px\", \"\"));\n            if (isNaN(offsetLeft)) {\n                //for fixed layouts, $htmlElement.css(\"left\") has no numerical value\n                offsetLeft = 0;\n            }\n            \n            if (this.context.isRTL && !this.context.paginationInfo().isVerticalWritingMode) return -offsetLeft;\n             \n            return offsetLeft;\n        },\n\n        _injectAnnotationCSS: function(annotationCSSUrl) {\n            var doc = this.context.document;\n            setTimeout(function(){\n                var $contentDocHead = $(\"head\", doc);\n                $contentDocHead.append(\n                    $(\"<link/>\", {\n                        rel: \"stylesheet\",\n                        href: annotationCSSUrl,\n                        type: \"text/css\"\n                    })\n                );\n            }, 0);\n        }\n    });\n\n    return HighlightsController;\n});\n\n",
    "//  Created by Dmitry Markushevich (dmitrym@evidentpoint.com)\n//\n//  Copyright (c) 2014 Readium Foundation and/or its licensees. All rights reserved.\n//\n//  Redistribution and use in source and binary forms, with or without modification,\n//  are permitted provided that the following conditions are met:\n//  1. Redistributions of source code must retain the above copyright notice, this\n//  list of conditions and the following disclaimer.\n//  2. Redistributions in binary form must reproduce the above copyright notice,\n//  this list of conditions and the following disclaimer in the documentation and/or\n//  other materials provided with the distribution.\n//  3. Neither the name of the organization nor the names of its contributors may be\n//  used to endorse or promote products derived from this software without specific\n//  prior written permission.\n//\n//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n//  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n//  OF THE POSSIBILITY OF SUCH DAMAGE.\n\ndefine('readium_plugin_highlights/manager',['jquery', 'underscore', 'eventEmitter', './controller', './helpers', 'readium_shared_js/models/bookmark_data'], function($, _, EventEmitter, HighlightsController, HighlightHelpers, BookmarkData) {\n\nvar defaultContext = {};\n\n//determine if browser is IE9 or IE10\nvar div = document.createElement(\"div\");\ndiv.innerHTML = \"<!--[if IE 9]><i></i><![endif]-->\";\ndefaultContext.isIe9 = (div.getElementsByTagName(\"i\").length == 1);\n// IE10 introduced a prefixed version of PointerEvent, but not unprefixed.\ndefaultContext.isIe10 = window.MSPointerEvent && !window.PointerEvent;\n\n/**\n *\n * @param proxyObj\n * @param options\n * @constructor\n */\nvar HighlightsManager = function (proxyObj, options) {\n\n    var self = this;\n\n    // live annotations contains references to the annotation _module_ for visible spines\n    var liveAnnotations = {};\n    var spines = {};\n    var proxy = proxyObj;\n    var annotationCSSUrl = options.annotationCSSUrl;\n\n    if (!annotationCSSUrl) {\n        console.warn(\"WARNING! Annotations CSS not supplied. Highlighting might not work.\");\n    }\n\n    _.extend(this, new EventEmitter());\n\n    // this.on(\"all\", function() {\n    // });\n    //TODO: EventEmitter3 does not support \"all\" or \"*\" (catch-all event sink)\n    //https://github.com/primus/eventemitter3/blob/master/index.js#L61\n    //...so instead we patch trigger() and emit() (which are synonymous, see Bootstrapper.js EventEmitter.prototype.trigger = EventEmitter.prototype.emit;)\n\n    var originalEmit = self['emit'];\n\n    var triggerEmitPatch = function() {\n        var args = Array.prototype.slice.call(arguments);\n        // mangle annotationClicked event. What really needs to happen is, the annotation_module needs to return a\n        // bare Cfi, and this class should append the idref.\n        var mangleEvent = function(annotationEvent){\n            if (args.length && args[0] === annotationEvent) {\n                for (var spineIndex in liveAnnotations)\n                {\n                    var contentDocumentFrame = args[5];\n                    var jQueryEvent = args[4];\n                    if (typeof jQueryEvent.clientX === 'undefined') {\n                        jQueryEvent.clientX = jQueryEvent.pageX;\n                        jQueryEvent.clientY = jQueryEvent.pageY;\n                    }\n\n                    var annotationId = args[3];\n                    var partialCfi = args[2];\n                    var type = args[1];\n                    if (liveAnnotations[spineIndex].getHighlight(annotationId)) {\n                        var idref = spines[spineIndex].idref;\n                        args = [annotationEvent, type, idref, partialCfi, annotationId, jQueryEvent, contentDocumentFrame];\n                    }\n                }\n            }\n        }\n        mangleEvent('annotationClicked');\n        mangleEvent('annotationTouched');\n        mangleEvent('annotationRightClicked');\n        mangleEvent('annotationHoverIn');\n        mangleEvent('annotationHoverOut');\n\n        originalEmit.apply(this, args);\n        originalEmit.apply(proxy, args);\n    };\n\n    this.trigger = triggerEmitPatch;\n    this.emit = triggerEmitPatch;\n\n    this.attachAnnotations = function($iframe, spineItem, loadedSpineItems) {\n        var iframe = $iframe[0];\n\n        var context = _.extend({\n            document: iframe.contentDocument,\n            window: iframe.contentWindow,\n            iframe: iframe,\n            manager: self,\n            cssUrl: annotationCSSUrl,\n            isFixedLayout: spineItem.isFixedLayout(),\n            isRTL: spineItem.spine.isRightToLeft(),\n            paginationInfo: function() { return spineItem.paginationInfo; }\n            \n        }, defaultContext);\n\n        liveAnnotations[spineItem.index] = new HighlightsController(context, {getVisibleCfiRangeFn: options.getVisibleCfiRangeFn});\n        spines[spineItem.index] = spineItem;\n\n        // check to see which spine indicies can be culled depending on the currently loaded spine items\n        for(var spineIndex in liveAnnotations) {\n            if (liveAnnotations.hasOwnProperty(spineIndex) && !_.contains(loadedSpineItems, spines[spineIndex])) {\n                delete liveAnnotations[spineIndex];\n            }\n        }\n    };\n\n    this.getCurrentSelectionCfi = function() {\n        for(var spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine];\n            var partialCfi = annotationsForView.getCurrentSelectionCFI();\n            if (partialCfi) {\n                return {\"idref\":spines[spine].idref, \"cfi\":partialCfi};\n            }\n        }\n        return undefined;\n    };\n\n    this.addSelectionHighlight = function(id, type, styles, clearSelection) {\n        for(var spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine];\n            if (annotationsForView.getCurrentSelectionCFI()) {\n                var annotation = annotationsForView.addSelectionHighlight(\n                    id, type, styles, clearSelection);\n                return new BookmarkData(spines[spine].idref, annotation.CFI);\n            }\n        }\n        return undefined;\n    };\n\n    this.addHighlight = function(spineIdRef, partialCfi, id, type, styles) {\n        for(var spine in liveAnnotations) {\n            if (spines[spine].idref === spineIdRef) {\n                var annotationsForView = liveAnnotations[spine];\n                var annotation = annotationsForView.addHighlight(partialCfi, id, type, styles);\n                if (annotation) {\n                    return new BookmarkData(spineIdRef, annotation.CFI);\n                }\n            }\n        }\n        return undefined;\n    };\n\n    this.removeHighlight = function(id) {\n        var result = undefined;\n        for(var spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine];\n            result  = annotationsForView.removeHighlight(id);\n        }\n        return result;\n    };\n\n    this.removeHighlightsByType = function(type) {\n        var result = undefined;\n        for(var spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine];\n            result  = annotationsForView.removeHighlightsByType(type);\n        }\n        return result;\n    };\n\n    this.getHighlight = function(id) {\n        var result = undefined;\n        for(var spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine];\n            result  = annotationsForView.getHighlight(id);\n            if (result !== undefined)\n\t\t\t\treturn result;\n        }\n        return result;\n    };\n\n    this.updateAnnotation = function(id, type, styles) {\n        var result = undefined;\n        for(var spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine];\n            result = annotationsForView.updateAnnotation(id, type, styles);\n            if(result) {\n                break;\n            }\n        }\n        return result;\n    };\n\n    this.replaceAnnotation = function(id, cfi, type, styles) {\n        var result = undefined;\n        for(var spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine];\n            result = annotationsForView.replaceAnnotation(id, cfi, type, styles);\n            if(result) {\n                break;\n            }\n        }\n        return result;\n    };\n\n    // redraw gets called on pagination change, so for progressive rendering we may have to add annotations that were previously not visible.\n    this.redrawAnnotations = function(){\n        for(var spine in liveAnnotations) {\n            liveAnnotations[spine].redraw();\n        }\n    };\n\n    this.updateAnnotationView = function(id, styles) {\n        var result = undefined;\n        for(var spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine];\n            result = annotationsForView.updateAnnotationView(id,styles);\n            if(result){\n                break;\n            }\n        }\n        return result;\n    };\n\n    this.setAnnotationViewState = function(id, state, value) {\n        var result = undefined;\n        for(var spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine];\n            result = annotationsForView.setAnnotationViewState(id, state, value);\n            if(result){\n                break;\n            }\n        }\n        return result;\n    };\n\n    this.setAnnotationViewStateForAll = function(state, value) {\n        var result = undefined;\n        for(var spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine];\n            result = annotationsForView.setAnnotationViewStateForAll(state, value);\n            if(result){\n                break;\n            }\n        }\n        return result;\n    };\n\n    this.cfiIsBetweenTwoCfis = function (cfi, lowBoundaryCfi, highBoundaryCfi) {\n        var result = undefined;\n        for(var spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine];\n            result = annotationsForView.cfiIsBetweenTwoCfis(cfi, lowBoundaryCfi, highBoundaryCfi);\n            if(result){\n                break;\n            }\n        }\n        return result;\n    };\n\n    this.contentCfiComparator = function(contCfi1, contCfi2) {\n        var result = undefined;\n        for(var spine in liveAnnotations) {\n            var annotationsForView = liveAnnotations[spine];\n            result = annotationsForView.contentCfiComparator(contCfi1, contCfi2);\n            if(result){\n                break;\n            }\n        }\n        return result;\n    };\n\n    function getElementFromViewElement(element) {\n        //TODO JC: yuck, we get two different collection structures from non fixed and fixed views.. must refactor..\n        return element.element ? element.element : element;\n    }\n\n    this.getAnnotationMidpoints = function($elementSpineItemCollection){\n        var output = [];\n\n        _.each($elementSpineItemCollection, function (item){\n            var annotations = [];\n\n            var lastId = null;\n\n            var baseOffset = {top: 0, left: 0};\n            if (item.elements && item.elements.length > 0) {\n                var firstElement = getElementFromViewElement(item.elements[0]);\n                var offsetElement = firstElement.ownerDocument.defaultView.frameElement.parentElement;\n                baseOffset = {top: offsetElement.offsetTop, left: offsetElement.offsetLeft};\n            }\n\n            _.each(item.elements, function(element){\n\n                var $element = $(getElementFromViewElement(element));\n                var elementId = $element.attr('data-id');\n\n                if(!elementId){\n                    console.warn('AnnotationsManager:getAnnotationMidpoints: Got an annotation element with no ID??')\n                    return;\n                }\n                if (elementId === lastId) return;\n                lastId = elementId;\n\n                //calculate position offsets with scaling\n                var scale = 1;\n                //figure out a better way to get the html parent from an element..\n                var $html = $element.parent();\n                //get transformation scale from content document\n                var matrix = HighlightHelpers.getMatrix($html);\n                if (matrix) {\n                    scale = HighlightHelpers.getScaleFromMatrix(matrix);\n                }\n                var offset = $element.offset();\n                offset.top += baseOffset.top + ($element.height() / 2);\n                offset.left += baseOffset.left;\n                if(scale !== 1){\n                    offset = {top: (offset.top * scale)*(1/scale), left: offset.left };\n                }\n                var $highlighted = {id: elementId, position: offset, lineHeight: parseInt($element.css('line-height'),10)};\n                annotations.push($highlighted)\n            });\n\n            output.push({annotations:annotations, spineItem: item.spineItem});\n        });\n\n        return output;\n    };\n\n    this.getAnnotationsElementSelector = function () {\n        return 'div.rd-highlight, div.rd-highlight-border';\n    };\n\n};\n\nreturn HighlightsManager;\n});\n\n",
    "define('readium_plugin_highlights/main',['readium_js_plugins', 'readium_shared_js/globals', './manager'], function (Plugins, Globals, HighlightsManager) {\n    var config = {};\n\n    Plugins.register(\"highlights\", function (api) {\n        var reader = api.reader, _highlightsManager, _initialized = false, _initializedLate = false;\n\n        var self = this;\n\n        function isInitialized() {\n            if (!_initialized) {\n                api.plugin.warn('Not initialized!')\n            }\n            return _initialized;\n        }\n\n        this.initialize = function (options) {\n            options = options || {};\n\n            setTimeout(isInitialized, 1000);\n\n            if (_initialized) {\n                api.plugin.warn('Already initialized!');\n                return;\n            }\n\n            if (reader.getFirstVisibleCfi && reader.getLastVisibleCfi && !options.getVisibleCfiRangeFn) {\n                options.getVisibleCfiRangeFn = function () {\n                    return {firstVisibleCfi: reader.getFirstVisibleCfi(), lastVisibleCfi: reader.getLastVisibleCfi()};\n                };\n            }\n\n            _highlightsManager = new HighlightsManager(self, options);\n\n            if (_initializedLate) {\n                api.plugin.warn('Unable to attach to currently loaded content document.\\n' +\n                'Initialize the plugin before loading a content document.');\n            }\n\n            _initialized = true;\n        };\n\n        this.getHighlightsManager = function() {\n            return _highlightsManager;\n        };\n\n        /**\n         * Returns current selection partial Cfi, useful for workflows that need to check whether the user has selected something.\n         *\n         * @returns {object | undefined} partial cfi object or undefined if nothing is selected\n         */\n        this.getCurrentSelectionCfi = function() {\n            return _highlightsManager.getCurrentSelectionCfi();\n        };\n\n        /**\n         * Creates a higlight based on given parameters\n         *\n         * @param {string} spineIdRef\t\tSpine idref that defines the partial Cfi\n         * @param {string} cfi\t\t\t\tPartial CFI (withouth the indirection step) relative to the spine index\n         * @param {string} id\t\t\t\tId of the highlight. must be unique\n         * @param {string} type \t\t\tName of the class selector rule in annotations stylesheet.\n         * \t\t\t\t\t\t\t\t\tThe style of the class will be applied to the created hightlight\n         * @param {object} styles\t\t\tObject representing CSS properties to be applied to the highlight.\n         * \t\t\t\t\t\t\t\t\te.g., to apply background color pass in: {'background-color': 'green'}\n         *\n         * @returns {object | undefined} partial cfi object of the created highlight\n         */\n        this.addHighlight = function(spineIdRef, cfi, id, type, styles) {\n            return _highlightsManager.addHighlight(spineIdRef, cfi, id, type, styles);\n        };\n\n        /**\n         * Creates a higlight based on the current selection\n         *\n         * @param {string} id id of the highlight. must be unique\n         * @param {string} type - name of the class selector rule in annotations.css file.\n         * @param {object} styles - object representing CSS properties to be applied to the highlight.\n         * e.g., to apply background color pass this {'background-color': 'green'}\n         * @param {boolean} clearSelection - set to true to clear the current selection\n         * after it is highlighted\n         *\n         * @returns {object | undefined} partial cfi object of the created highlight\n         */\n        this.addSelectionHighlight =  function(id, type, styles, clearSelection) {\n            return _highlightsManager.addSelectionHighlight(id, type, styles, clearSelection);\n        };\n\n        /**\n         * Removes a given highlight\n         *\n         * @param {string} id  The id associated with the highlight.\n         *\n         * @returns {undefined}\n         *\n         */\n        this.removeHighlight = function(id) {\n            return _highlightsManager.removeHighlight(id);\n        };\n\n        /**\n         * Removes highlights of a given type\n         *\n         * @param {string} type type of the highlight.\n         *\n         * @returns {undefined}\n         *\n         */\n        this.removeHighlightsByType = function(type) {\n            return _highlightsManager.removeHighlightsByType(type);\n        };\n\n        /**\n         * Client Rectangle\n         * @typedef {object} ReadiumSDK.Views.ReaderView.ClientRect\n         * @property {number} top\n         * @property {number} left\n         * @property {number} height\n         * @property {number} width\n         */\n\n        /**\n         * Highlight Info\n         *\n         * @typedef {object} ReadiumSDK.Views.ReaderView.HighlightInfo\n         * @property {string} id - unique id of the highlight\n         * @property {string} type - highlight type (css class)\n         * @property {string} CFI - partial CFI range of the highlight\n         * @property {ReadiumSDK.Views.ReaderView.ClientRect[]} rectangleArray - array of rectangles consituting the highlight\n         * @property {string} selectedText - concatenation of highlight nodes' text\n         */\n\n        /**\n         * Gets given highlight\n         *\n         * @param {string} id id of the highlight.\n         *\n         * @returns {ReadiumSDK.Views.ReaderView.HighlightInfo} Object describing the highlight\n         */\n        this.getHighlight = function(id) {\n            return _highlightsManager.getHighlight(id);\n        };\n\n        /**\n         * Update annotation by the id, reapplies CSS styles to the existing annotaion\n         *\n         * @param {string} id id of the annotation.\n         * @property {string} type - annotation type (name of css class)\n         * @param {object} styles - object representing CSS properties to be applied to the annotation.\n         * e.g., to apply background color pass this {'background-color': 'green'}.\n         */\n        this.updateAnnotation = function(id, type, styles) {\n            _highlightsManager.updateAnnotation(id, type, styles);\n        };\n\n        /**\n         * Replace annotation with this id. Current annotation is removed and a new one is created.\n         *\n         * @param {string} id id of the annotation.\n         * @property {string} cfi - partial CFI range of the annotation\n         * @property {string} type - annotation type (name of css class)\n         * @param {object} styles - object representing CSS properties to be applied to the annotation.\n         * e.g., to apply background color pass this {'background-color': 'green'}.\n         */\n        this.replaceAnnotation = function(id, cfi, type, styles) {\n            _highlightsManager.replaceAnnotation(id, cfi, type, styles);\n        };\n\n\n        /**\n         * Redraws all annotations\n         */\n        this.redrawAnnotations = function() {\n            _highlightsManager.redrawAnnotations();\n        };\n\n        /**\n         * Updates an annotation to use the supplied styles\n         *\n         * @param {string} id\n         * @param {string} styles\n         */\n        this.updateAnnotationView = function(id, styles) {\n            _highlightsManager.updateAnnotationView(id, styles);\n        };\n\n        /**\n         * Updates an annotation view state, such as whether its hovered in or not.\n         * @param {string} id       The id associated with the highlight.\n         * @param {string} state    The state type to be updated\n         * @param {string} value    The state value to apply to the highlight\n         * @returns {undefined}\n         */\n        this.setAnnotationViewState = function(id, state, value) {\n            return _highlightsManager.setAnnotationViewState(id, state, value);\n        };\n\n        /**\n         * Updates an annotation view state for all views.\n         * @param {string} state    The state type to be updated\n         * @param {string} value    The state value to apply to the highlights\n         * @returns {undefined}\n         */\n        this.setAnnotationViewStateForAll = function (state, value) {\n            return _highlightsManager.setAnnotationViewStateForAll(state, value);\n        };\n\n        /**\n         * Gets a list of the visible midpoint positions of all annotations\n         *\n         * @returns {HTMLElement[]}\n         */\n        this.getVisibleAnnotationMidpoints = function () {\n            if (reader.getVisibleElements) {\n                var $visibleElements = reader.getVisibleElements(_highlightsManager.getAnnotationsElementSelector(), true);\n\n                var elementMidpoints = _highlightsManager.getAnnotationMidpoints($visibleElements);\n                return elementMidpoints || [];\n            } else {\n                // FIXME: Expose the getVisibleElements call from the reader's internal views.\n                console.warn('getAnnotationMidpoints won\\'t work with this version of Readium');\n            }\n        };\n\n        reader.on(Globals.Events.CONTENT_DOCUMENT_LOADED, function ($iframe, spineItem) {\n            if (_initialized) {\n                _highlightsManager.attachAnnotations($iframe, spineItem, reader.getLoadedSpineItems());\n            } else {\n                _initializedLate = true;\n            }\n        });\n\n        ////FIXME: JCCR mj8: this is sometimes faulty, consider removal\n        //// automatically redraw annotations.\n        //reader.on(ReadiumSDK.Events.PAGINATION_CHANGED, _.debounce(function () {\n        //    self.redrawAnnotations();\n        //}, 10, true));\n\n\n\n    });\n\n    return config;\n});\n\ndefine('readium_plugin_highlights', ['readium_plugin_highlights/main'], function (main) { return main; });\n\n",
    "\ndefine(\"readium-plugin-highlights\", function(){});\n",
    "\nrequire([\"readium_plugin_highlights\"]);\n"
  ]
}